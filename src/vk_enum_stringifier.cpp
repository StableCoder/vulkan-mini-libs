/*
    Copyright (C) 2020 George Cave - gcave@stablecoder.ca

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#include <rapidxml-1.13/rapidxml.hpp>

#include <algorithm>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

const char *headerFileStr = R"HEADER(/**
 * This file was auto-generated by the Vulkan Enum Stringifier
 * that is located at https://github.com/stablecoder/vk-enum-stringifier
 * or https://git.stabletec.com/utilities/vk-enum-stringifier
 *
 * Check for an updated version anytime, or state concerns/bugs.
 */

#ifndef VK_ENUM_STRINGIFIER_HPP
#define VK_ENUM_STRINGIFIER_HPP

#include <cstdint>
#include <string>
#include <string_view>

namespace vkEnum {

/**
 * @brief Parses a given enum type/value for an enum type
 * @param enumType Vulkan enum typename as a string
 * @param value String of the value to parse
 *
 * Formats the string and attempts to find a match, and returns it. Enums can only match one.
 */
uint32_t parseEnum(std::string_view enumType, std::string value);

/**
 * @brief Parses a given enum type/value(s) for a mask type
 * @param enumType Vulkan enum typename as a string
 * @param value String of the value(s) to parse.
 *
 * Tokenizes the given value string, delimited by '|', and for each token attempts to find the value
 * in the provided enum value set, and if found, OR's it witht eh current return value.
 */
uint32_t parseBitmask(std::string_view enumType, std::string value);

/**
 * @brief Stringifies a given Vk type/value for an enum
 * @param enumType Vulkan enum typename as a string
 * @param enumValue Value to convert into a string
 * @return Short string representing the enum value, or an empty string if not found.
 */
std::string stringifyEnum(std::string_view enumType, uint32_t enumValue);

/**
 * @brief Stringifies a given Vk type/value for a bitmask
 * @param enumType Vulkan enum typename as a string
 * @param enumValue Value to convert into a string
 * @return Short string representing the bitmask values delimited by the '|' symbol, or an empty
 * string if not found.
 */
std::string stringifyBitmask(std::string_view enumType, uint32_t enumValue);

}

#endif // VK_ENUM_STRINGIFIER_HPP
)HEADER";

const char *descriptionStr = R"DESC(/**
 * This file was auto-generated by the Vulkan Enum Stringifier
 * that is located at https://github.com/stablecoder/vk-enum-stringifier
 * or https://git.stabletec.com/utilities/vk-enum-stringifier
 *
 * Check for an updated version anytime, or state concerns/bugs.
 */
)DESC";

const char *includesStr = R"HEADER(
#include <algorithm>
#include <cctype>
#include <cstring>
#include <locale>
#include <memory>
#include <string>
#include <string_view>
#include <tuple>

namespace {

)HEADER";

const char *commonFunctionsStr = R"COMMON(
/**
 * @brief Returns the start->end pointer range for valid value sets for the given typename
 * @param enumType Vulkan enum typename
 * @return Pointer range, or nullptr's if type isn't found.
 */
std::tuple<const EnumValueSet *, const EnumValueSet *> getValueSets(std::string_view enumType) {
    for (std::size_t i = 0; i < enumTypesCount; ++i) {
        if (enumType == std::string_view{enumTypes[i].name}) {
            return std::make_tuple(valueSets[i], valueSets[i] + enumTypes[i].count);
        }
    }

    return std::make_tuple(nullptr, nullptr);
}

/**
 * @brief Takes a given string and formats it for use with parsing
 * @param str The string to format
 * @return Formatted string
 *
 * First, any non alphanumeric characters are trimmed from both ends of the string.
 * After than, any spaces are replaced with underscores, and finally all the characters are
 * capitalized. This will generate the string closest to the original ones found in the XML spec.
 */
std::string formatString(std::string str) {
    // Trim left
    std::size_t cutOffset = 0;
    for (auto c : str) {
        if (isalnum(c, std::locale{}))
            break;
        else
            ++cutOffset;
    }
    str = str.substr(cutOffset);

    // Trim right
    cutOffset = 0;
    for (std::size_t i = 0; i < str.size(); ++i) {
        if (isalnum(str[i]))
            cutOffset = i + 1;
    }
    str = str.substr(0, cutOffset);

    std::replace(str.begin(), str.end(), ' ', '_');
    std::for_each(str.begin(), str.end(), [](char &c) { c = ::toupper(c); });

    return str;
}

/**
 * @brief Removes a vendor tag from the end of the given string view
 * @param view String view to remove the vendor tag from
 * @return A string_view without the vendor tag, if it was suffixed
 */
std::string_view removeVendorTag(std::string_view view) {
    for (std::size_t i = 0; i < vendorTagCount; ++i) {
        std::size_t vendorSize = strlen(vendorTags[i]);
        if (strncmp(view.data() + view.size() - vendorSize, vendorTags[i], vendorSize) == 0) {
            view = view.substr(0, view.size() - strlen(vendorTags[i]));
            break;
        }
    }

    return view;
}

/**
 * @brief Converts a Vulakn Flag typename into the prefix that is used for it's enums
 * @param typeName Name of the type to generate the Vk enum prefix for
 * @return Generated prefix string
 *
 * Any capitalized letters except for the first has an underscore inserted before it, an underscore
 * is added to the end, and all characters are converted to upper case.
 */
std::string processEnumPrefix(std::string_view typeName) {
    std::size_t size = strlen("FlagBits");
    if (typeName.size() > size) {
        if (strncmp(typeName.data() + typeName.size() - size, "FlagBits", size) == 0) {
            typeName = typeName.substr(0, typeName.size() - strlen("FlagBits"));
        }
    }

        std::string retStr;
    for (auto it = typeName.begin(); it != typeName.end(); ++it) {
        if (it == typeName.begin()) {
            retStr += ::toupper(*it);
        } else if (::isupper(*it)) {
            retStr += '_';
            retStr += *it;
        } else {
            retStr += toupper(*it);
        }
    }
    retStr += '_';

    return retStr;
}

/**
 * @brief Returns the value for the given type/value
 * @param enumType Vulkan enum typename
 * @param enumPrefix The normal prefix for the enum's values
 * @param enumName Name of the enum value to find
 * @return The associated value, or zero if not found otherwise.
 */
uint32_t findValue(std::string_view enumType,
                   std::string_view enumPrefix,
                   std::string_view enumName) {
    // Figure out which ValueSet the enum given corresponds to
    auto [start, end] = getValueSets(enumType);

    // With the given sets/count, iterate until we find the value
    while (start != end) {
        if (enumName == std::string_view{start->name}) {
            return start->value;
        }

        std::string prefixedName{enumPrefix.begin(), enumPrefix.end()};
        prefixedName += start->name;
        if (enumName == prefixedName) {
            return start->value;
        }

        ++start;
    }

    return 0;
}

}

namespace vkEnum {

uint32_t parseEnum(std::string_view enumType, std::string value) {
    auto prefix = processEnumPrefix(removeVendorTag(enumType));
    value = formatString(value);

    return findValue(enumType, prefix, value);
}

uint32_t parseBitmask(std::string_view enumType, std::string value) {
    auto prefix = processEnumPrefix(removeVendorTag(enumType));
    uint32_t retVal = 0;

    auto startCh = value.begin();
    auto endCh = startCh;
    for (; endCh != value.end(); ++endCh) {
        if (*endCh == '|') {
            std::string token(startCh, endCh);
            token = formatString(token);

            retVal |= findValue(enumType, prefix, token);

            startCh = endCh + 1;
        }
    }
    if (startCh != endCh) {
        std::string token(startCh, endCh);
        token = formatString(token);

        retVal |= findValue(enumType, prefix, token);
    }

    return retVal;
}

std::string stringifyEnum(std::string_view enumType, uint32_t enumValue) {
    auto [start, end] = getValueSets(enumType);

    while (start != end) {
        if (start->value == enumValue) {
            return start->name;
        }

        ++start;
    }

    return "";
}

std::string stringifyBitmask(std::string_view enumType, uint32_t enumValue) {
    auto [end, start] = getValueSets(enumType);
    --end;
    --start;

    std::string retStr;

    while (start != end && enumValue != 0) {
        if ((start->value & enumValue) == start->value) {
            // Found a compatible bit mask, add it
            if (!retStr.empty()) {
                retStr += " | ";
            }
            retStr += start->name;
            enumValue = enumValue ^ start->value;
        }

        --start;
    }

    return retStr;
}

}
)COMMON";

const char *helpStr = R"HELP(
This program builds a source/header file for use in C++20 or newer. It lists
contains all Vulkan enum types/flags/values of the indicated Vulkan header spec
version, and can convert to/from strings representing those values. 

Supports both plain enums and the bitmasks.

When converting values to strings, where possible a shorter version of the
enum string is used, where the verbose type prefix is removed:
    VK_IMAGE_LAYOUT_GENERAL => GENERAL
    VK_CULL_MODE_FRONT_BIT | VK_CULL_MODE_BACK_BIT => FRONT | BACK

When converting from strings into values, either the short OR full string can
be used where strings are case insensitive, and underscores can be replaced
with spaces, and addition whitespace can be added to either side of the first/
last alphanumeric character, as these are trimmed off.

For example, all of the following conver to VK_IMAGE_LAYOUT_GENERAL:
`vk imAGE_LayOut GenerAL`, `VK_IMAGE_LAYOUT_GENERAL`,`GENERAL`, `   General `

Also, to assist with forward and backwards compatability, all the vendor tags
are stripped from the typenames and values, since they can be removed in later
versions leading to incompatability issues.

Program Arguments:
    -h, --help  : Help Blurb
    -i, --input : Input vk.xml file to parse. These can be found from the 
                    KhronosGroup, often at this repo:
                    https://github.com/KhronosGroup/Vulkan-Docs
    -d, --dir   : Output directory
    -o, --out   : Output file name, note that there will be both a .cpp and
                    .hpp variant generated. (Default: `vk_enum_stringifier`)
)HELP";

/**
 * @brief Removes a vendor tag from the end of the given string view
 * @param vendorTags List of vedor tags to check against
 * @param view String view to remove the vendor tag from
 * @return A string_view without the vendor tag, if it was suffixed
 */
std::string_view removeVendorTag(const std::vector<std::string> &vendorTags,
                                 std::string_view view) {
    for (auto &it : vendorTags) {
        if (strncmp(view.data() + view.size() - it.size(), it.data(), it.size()) == 0) {
            view = view.substr(0, view.size() - it.size());
            break;
        }
    }

    return view;
}

/**
 * @brief Converts a Vulakn Flag typename into the prefix that is used for it's enums
 * @param typeName Name of the type to generate the Vk enum prefix for
 * @return Generated prefix string
 *
 * Any capitalized letters except for the first has an underscore inserted before it, an underscore
 * is added to the end, and all characters are converted to upper case.
 */
std::string processEnumPrefix(const std::vector<std::string> &vendorTags,
                              std::string_view typeName) {
    std::size_t size = strlen("FlagBits");
    if (typeName.size() > size) {
        if (strncmp(typeName.data() + typeName.size() - size, "FlagBits", size) == 0) {
            typeName = typeName.substr(0, typeName.size() - strlen("FlagBits"));
        }
    }

    std::string retStr;
    for (auto it = typeName.begin(); it != typeName.end(); ++it) {
        if (it == typeName.begin()) {
            retStr += ::toupper(*it);
        } else if (::isupper(*it)) {
            retStr += '_';
            retStr += *it;
        } else {
            retStr += toupper(*it);
        }
    }
    retStr += '_';

    return retStr;
}

/**
 * @brief Trims non alphanumeric characters from the string view
 * @param view Itme to trim
 * @return Trimmed string view
 */
std::string_view trimNonAlNum(std::string_view view) {
    if (view.empty())
        return view;

    // Trim left
    for (std::size_t i = 0; i < view.size(); ++i) {
        if (::isalnum(view[i])) {
            view = view.substr(i);
            break;
        }
    }

    if (view.empty())
        return view;

    // Trim right
    for (std::size_t i = view.size() - 1; i >= 0; --i) {
        if (::isalnum(view[i])) {
            view = view.substr(0, i + 1);
            break;
        }
    }

    return view;
}

int main(int argc, char **argv) {
    std::string inputFile;
    std::string outputDir;
    std::string outputFile = "vk_enum_stringifier";

    for (int i = 0; i < argc; ++i) {
        if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            std::cout << helpStr << std::endl;
            return 0;
        } else if (strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--input") == 0) {
            if (i + 1 <= argc) {
                inputFile = argv[i + 1];
            }
        } else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--dir") == 0) {
            if (i + 1 <= argc) {
                outputDir = argv[i + 1];
            }
        } else if (strcmp(argv[i], "-o") == 0 || strcmp(argv[i], "--out") == 0) {
            if (i + 1 <= argc) {
                outputFile = argv[i + 1];
            }
        }
    }

    if (inputFile == "") {
        std::cout << "Error: No input file given. Type --help for help." << std::endl;
        return 0;
    }

    // In order to parse a file, we need to load the whole thing into memory.
    std::ifstream inFile(inputFile.c_str(), std::ifstream::in);
    if (!inFile.is_open()) {
        std::cout << "Error: Failed to open file " << inputFile << std::endl;
        return 0;
    }
    // Seek to the end.
    inFile.seekg(0, std::ifstream::end);
    // Tell us how many chars to set aside.
    std::size_t fileSize = inFile.tellg();

    char *xmlContent = new char[fileSize];

    inFile.seekg(0, std::ifstream::beg);
    inFile.read(xmlContent, fileSize);
    inFile.close();

    // XML Parsing
    rapidxml::xml_document<> vkDoc;
    vkDoc.parse<0>(xmlContent);

    // Baselevel node should be <registry>
    rapidxml::xml_node<> *registryNode = vkDoc.first_node("registry");
    if (registryNode == nullptr) {
        std::cerr << "Error: No <registry> top-level tag found. Invalid vk.xml document."
                  << std::endl;
        return 1;
    }

    // Types node
    // To retrieve the Vulkan version information
    int vkHeaderVersion = -1;
    {
        rapidxml::xml_node<> *typesNode = registryNode->first_node("types");

        rapidxml::xml_node<> *endTypeNode = typesNode->last_node("type");
        for (auto *typeNode = typesNode->first_node("type"); typeNode != endTypeNode;
             typeNode = typeNode->next_sibling()) {
            if (strcmp("// Version of this file\n#define ", typeNode->value()) == 0) {
                // Go through the contents, the third sibling will have the header version
                auto *node = typeNode->first_node()->next_sibling()->next_sibling();
                vkHeaderVersion = std::stoi(node->value());
                break;
            }
        }
    }
    if (vkHeaderVersion == -1) {
        std::cerr << "Error: Could not determine vk.xml header version." << std::endl;
        return 1;
    }

    std::vector<std::string> vendorTagList;
    std::stringstream vendorTags;
    { // Vendor Tags
        vendorTags << "constexpr const char* vendorTags[] = {\n";

        std::size_t tagCount = 0;

        // Process 'tags' node
        auto *tagsNode = registryNode->first_node("tags");
        auto const *endTagNode = tagsNode->last_node("tag");
        for (auto tagNode = tagsNode->first_node("tag"); true; tagNode = tagNode->next_sibling()) {
            ++tagCount;
            auto *name = tagNode->first_attribute("name");

            vendorTags << "    \"" << name->value() << "\",\n";
            vendorTagList.emplace_back(name->value());

            if (tagNode == endTagNode)
                break;
        }

        vendorTags << "};\n";
        vendorTags << "constexpr const std::size_t vendorTagCount = " << tagCount << ";\n";
    }

    std::stringstream enumDecl;
    std::stringstream valueSets;
    std::stringstream valueSetArr;

    // Starts of each stream
    enumDecl << R"DECL(
struct EnumDeclaration {
    const char *name;
    std::size_t count;
};
EnumDeclaration enumTypes[] = {
)DECL";

    valueSets << R"SETS(
struct EnumValueSet {
    const char *name;
    uint32_t value;
};
)SETS";

    valueSetArr << R"ARR(
constexpr const EnumValueSet *valueSets[] = {
)ARR";

    std::size_t enumsCount = 0;

    // Process 'enums' nodes
    auto const *endEnumsNode = registryNode->last_node("enums");
    for (auto *enumsNode = registryNode->first_node("enums"); true;
         enumsNode = enumsNode->next_sibling()) {
        auto *nameAttr = enumsNode->first_attribute("name");
        if (nameAttr == nullptr || strcmp("API Constants", nameAttr->value()) == 0 ||
            strcmp("VkResult", nameAttr->value()) == 0)
            continue;

        ++enumsCount;
        auto *typeAttr = enumsNode->first_attribute("type")->value();

        // Generate prefix
        auto nonVendorName = removeVendorTag(vendorTagList, nameAttr->value());
        std::string prefix = processEnumPrefix(vendorTagList, nonVendorName);

        std::size_t enumCount = 0;
        if (enumsNode->first_node() != nullptr) {
            // Process each 'enum' within
            std::vector<std::pair<std::string, std::string>> enums;

            auto const *endEnum = enumsNode->last_node("enum");
            for (auto *enumNode = enumsNode->first_node("enum"); true;
                 enumNode = enumNode->next_sibling()) {
                if (strcmp(enumNode->name(), "enum") != 0)
                    continue;

                ++enumCount;

                if (enumCount == 1) {
                    valueSets << "constexpr const EnumValueSet " << nameAttr->value()
                              << "Sets[] = {\n";
                }

                std::string_view name = enumNode->first_attribute("name")->value();
                name = removeVendorTag(vendorTagList, name);
                name = trimNonAlNum(name);

                if (const auto *value = enumNode->first_attribute("value"); value != nullptr) {
                    // Plain value
                    enums.emplace_back(std::pair{name, value->value()});
                } else if (const auto *bitpos = enumNode->first_attribute("bitpos");
                           bitpos != nullptr) {
                    // Bitpos value
                    std::stringstream ss;
                    ss << "0x" << std::hex << std::setw(8) << std::uppercase << std::setfill('0')
                       << (1U << atoi(bitpos->value()));
                    enums.emplace_back(std::pair{name, ss.str()});
                } else if (const auto *alias = enumNode->first_attribute("alias");
                           alias != nullptr) {
                    // Alias
                    bool found = false;
                    for (auto &it : enums) {
                        std::string_view aliasView = alias->value();
                        aliasView = removeVendorTag(vendorTagList, aliasView);
                        aliasView = trimNonAlNum(aliasView);
                        if (strncmp(std::get<0>(it).data(), aliasView.data(), aliasView.size()) ==
                            0) {
                            enums.emplace_back(name, std::get<1>(it));
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        std::cerr << "Error: Couldn't find alias for " << name << std::endl;
                        return 1;
                    }
                } else {
                    std::cerr << "Error: Enum type unsupported: " << typeAttr << std::endl;
                    return 1;
                }

                if (endEnum == enumNode)
                    break;
            }

            for (auto &it : enums) {
                if (strncmp(std::get<0>(it).data(), prefix.data(), prefix.size()) == 0) {
                    valueSets << "    {\"" << std::get<0>(it).substr(prefix.size()) << "\", ";
                } else {
                    valueSets << "    {\"" << std::get<0>(it) << "\", ";
                }
                valueSets << std::get<1>(it) << "},\n";
            }
        }

        // Finish up the end of the enum for the streams
        enumDecl << "    {\"" << nameAttr->value() << "\", " << enumCount << "},\n";
        if (enumCount != 0) {
            valueSets << "};\n";
            valueSetArr << "    " << nameAttr->value() << "Sets,\n";
        } else {
            valueSetArr << "    nullptr,\n";
        }

        if (enumsNode == endEnumsNode)
            break;
    }

    valueSetArr << "};\n";
    enumDecl << "};\n";
    enumDecl << "constexpr const std::size_t enumTypesCount = " << enumsCount << ";\n";

    { // Header File
        std::ofstream outFile(outputDir + outputFile + ".hpp");
        if (!outFile.is_open()) {
            std::cerr << "Error: Failed to open output file for writing: " << outputDir
                      << outputFile << ".hpp" << std::endl;
            return 1;
        }

        outFile << "\n/* !! Generated using Vulkan XML spec version " << vkHeaderVersion
                << " !! */\n\n";
        outFile << headerFileStr;
    }

    { // Source File
        std::ofstream outFile(outputDir + outputFile + ".cpp");
        if (!outFile.is_open()) {
            std::cerr << "Error: Failed to open output file for writing: " << outputDir
                      << outputFile << ".cpp" << std::endl;
            return 1;
        }

        // First, write the license/disclaimer
        outFile << "\n/* !! Generated using Vulkan XML spec version " << vkHeaderVersion
                << " !! */\n\n";
        outFile << descriptionStr;
        outFile << includesStr;

        outFile << vendorTags.str();

        outFile << enumDecl.str();
        outFile << valueSets.str();
        outFile << valueSetArr.str();

        outFile << commonFunctionsStr;
    }

    return 0;
}