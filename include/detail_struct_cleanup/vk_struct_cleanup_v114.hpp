/*
    Copyright (C) 2020 George Cave - gcave@stablecoder.ca

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/*
    This file was auto-generated by the Vulkan mini-libs utility can be found at
    https://github.com/stablecoder/vulkan-mini-libs.git
    or
    https://git.stabletec.com/utilities/vulkan-mini-libs.git

    Check for an updated version anytime, or state concerns/bugs.
*/

#ifndef VK_STRUCT_CLEANUP_V114_HPP
#define VK_STRUCT_CLEANUP_V114_HPP

/*  USAGE:
    To use, include this header where the declarations for the boolean checks are required.

    On *ONE* compilation unit, include the definition of `#define VK_STRUCT_CLEANUP_CONFIG_MAIN`
    so that the definitions are compiled somewhere following the one definition rule.
*/

#include <vulkan/vulkan.h>

static_assert(VK_HEADER_VERSION == 114, "Incompatible VK_HEADER_VERSION!" );

/** @brief Cleans up a Vulkan sType-based structure of pointer data
 * @param pData Pointer to the struct to be cleaned up
 * 
 * This function is only to be called on Vulkan structures that *have* a VkStructureType
 * member 'sType'. Any pointer members that start with 'p[A-Z]' are assumed to be *owned*
 * by the struct and are themselves cleaned up recusrively, and then deleted.
 *
 * This means any other pointer members, or pointer to pointer members are not cleaned up
 * and would still require manual deletion.
 */
void vk_struct_cleanup(void const* pData);

#ifdef VK_STRUCT_CLEANUP_CONFIG_MAIN

#include <cstdlib>

void vk_struct_cleanup(void const *pData) {
    if (pData == nullptr)
        return;

    struct VkTempStruct {
        VkStructureType sType;
    };
    VkTempStruct const *pTemp = static_cast<VkTempStruct const *>(pData);

    switch (pTemp->sType) {
    case VK_STRUCTURE_TYPE_APPLICATION_INFO:
        {   // VkApplicationInfo
            VkApplicationInfo const *pStruct = static_cast<VkApplicationInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pApplicationName / null-terminated
            free(const_cast<char *>(pStruct->pApplicationName));

            // char - pEngineName / null-terminated
            free(const_cast<char *>(pStruct->pEngineName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
        {   // VkDeviceQueueCreateInfo
            VkDeviceQueueCreateInfo const *pStruct = static_cast<VkDeviceQueueCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // float - pQueuePriorities / queueCount
            free(const_cast<float *>(pStruct->pQueuePriorities));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
        {   // VkDeviceCreateInfo
            VkDeviceCreateInfo const *pStruct = static_cast<VkDeviceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDeviceQueueCreateInfo - pQueueCreateInfos / queueCreateInfoCount
            for (uint32_t i = 0; i < pStruct->queueCreateInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pQueueCreateInfos[i]);
            free(const_cast<VkDeviceQueueCreateInfo *>(pStruct->pQueueCreateInfos));

            // VkPhysicalDeviceFeatures - pEnabledFeatures
            free(const_cast<VkPhysicalDeviceFeatures *>(pStruct->pEnabledFeatures));
        }

        break;

    case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
        {   // VkInstanceCreateInfo
            VkInstanceCreateInfo const *pStruct = static_cast<VkInstanceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkApplicationInfo - pApplicationInfo
            vk_struct_cleanup(pStruct->pApplicationInfo);
            free(const_cast<VkApplicationInfo *>(pStruct->pApplicationInfo));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
        {   // VkMemoryAllocateInfo
            VkMemoryAllocateInfo const *pStruct = static_cast<VkMemoryAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
        {   // VkMappedMemoryRange
            VkMappedMemoryRange const *pStruct = static_cast<VkMappedMemoryRange const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
        {   // VkWriteDescriptorSet
            VkWriteDescriptorSet const *pStruct = static_cast<VkWriteDescriptorSet const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorImageInfo - pImageInfo / descriptorCount
            free(const_cast<VkDescriptorImageInfo *>(pStruct->pImageInfo));

            // VkDescriptorBufferInfo - pBufferInfo / descriptorCount
            free(const_cast<VkDescriptorBufferInfo *>(pStruct->pBufferInfo));

            // VkBufferView - pTexelBufferView / descriptorCount
            free(const_cast<VkBufferView *>(pStruct->pTexelBufferView));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
        {   // VkCopyDescriptorSet
            VkCopyDescriptorSet const *pStruct = static_cast<VkCopyDescriptorSet const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
        {   // VkBufferCreateInfo
            VkBufferCreateInfo const *pStruct = static_cast<VkBufferCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
        {   // VkBufferViewCreateInfo
            VkBufferViewCreateInfo const *pStruct = static_cast<VkBufferViewCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
        {   // VkMemoryBarrier
            VkMemoryBarrier const *pStruct = static_cast<VkMemoryBarrier const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
        {   // VkBufferMemoryBarrier
            VkBufferMemoryBarrier const *pStruct = static_cast<VkBufferMemoryBarrier const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
        {   // VkImageMemoryBarrier
            VkImageMemoryBarrier const *pStruct = static_cast<VkImageMemoryBarrier const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
        {   // VkImageCreateInfo
            VkImageCreateInfo const *pStruct = static_cast<VkImageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
        {   // VkImageViewCreateInfo
            VkImageViewCreateInfo const *pStruct = static_cast<VkImageViewCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
        {   // VkBindSparseInfo
            VkBindSparseInfo const *pStruct = static_cast<VkBindSparseInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pWaitSemaphores / waitSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pWaitSemaphores));

            // VkSparseBufferMemoryBindInfo - pBufferBinds / bufferBindCount
            free(const_cast<VkSparseBufferMemoryBindInfo *>(pStruct->pBufferBinds));

            // VkSparseImageOpaqueMemoryBindInfo - pImageOpaqueBinds / imageOpaqueBindCount
            free(const_cast<VkSparseImageOpaqueMemoryBindInfo *>(pStruct->pImageOpaqueBinds));

            // VkSparseImageMemoryBindInfo - pImageBinds / imageBindCount
            free(const_cast<VkSparseImageMemoryBindInfo *>(pStruct->pImageBinds));

            // VkSemaphore - pSignalSemaphores / signalSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pSignalSemaphores));
        }

        break;

    case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {   // VkShaderModuleCreateInfo
            VkShaderModuleCreateInfo const *pStruct = static_cast<VkShaderModuleCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pCode / codeSize
            free(const_cast<uint32_t *>(pStruct->pCode));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
        {   // VkDescriptorSetLayoutCreateInfo
            VkDescriptorSetLayoutCreateInfo const *pStruct = static_cast<VkDescriptorSetLayoutCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorSetLayoutBinding - pBindings / bindingCount
            free(const_cast<VkDescriptorSetLayoutBinding *>(pStruct->pBindings));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
        {   // VkDescriptorPoolCreateInfo
            VkDescriptorPoolCreateInfo const *pStruct = static_cast<VkDescriptorPoolCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorPoolSize - pPoolSizes / poolSizeCount
            free(const_cast<VkDescriptorPoolSize *>(pStruct->pPoolSizes));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
        {   // VkDescriptorSetAllocateInfo
            VkDescriptorSetAllocateInfo const *pStruct = static_cast<VkDescriptorSetAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorSetLayout - pSetLayouts / descriptorSetCount
            free(const_cast<VkDescriptorSetLayout *>(pStruct->pSetLayouts));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
        {   // VkPipelineShaderStageCreateInfo
            VkPipelineShaderStageCreateInfo const *pStruct = static_cast<VkPipelineShaderStageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pName / null-terminated
            free(const_cast<char *>(pStruct->pName));

            // VkSpecializationInfo - pSpecializationInfo
            free(const_cast<VkSpecializationInfo *>(pStruct->pSpecializationInfo));
        }

        break;

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
        {   // VkComputePipelineCreateInfo
            VkComputePipelineCreateInfo const *pStruct = static_cast<VkComputePipelineCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
        {   // VkPipelineVertexInputStateCreateInfo
            VkPipelineVertexInputStateCreateInfo const *pStruct = static_cast<VkPipelineVertexInputStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVertexInputBindingDescription - pVertexBindingDescriptions / vertexBindingDescriptionCount
            free(const_cast<VkVertexInputBindingDescription *>(pStruct->pVertexBindingDescriptions));

            // VkVertexInputAttributeDescription - pVertexAttributeDescriptions / vertexAttributeDescriptionCount
            free(const_cast<VkVertexInputAttributeDescription *>(pStruct->pVertexAttributeDescriptions));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
        {   // VkPipelineInputAssemblyStateCreateInfo
            VkPipelineInputAssemblyStateCreateInfo const *pStruct = static_cast<VkPipelineInputAssemblyStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
        {   // VkPipelineTessellationStateCreateInfo
            VkPipelineTessellationStateCreateInfo const *pStruct = static_cast<VkPipelineTessellationStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
        {   // VkPipelineViewportStateCreateInfo
            VkPipelineViewportStateCreateInfo const *pStruct = static_cast<VkPipelineViewportStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewport - pViewports / viewportCount
            free(const_cast<VkViewport *>(pStruct->pViewports));

            // VkRect2D - pScissors / scissorCount
            free(const_cast<VkRect2D *>(pStruct->pScissors));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
        {   // VkPipelineRasterizationStateCreateInfo
            VkPipelineRasterizationStateCreateInfo const *pStruct = static_cast<VkPipelineRasterizationStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
        {   // VkPipelineMultisampleStateCreateInfo
            VkPipelineMultisampleStateCreateInfo const *pStruct = static_cast<VkPipelineMultisampleStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSampleMask - pSampleMask / rasterizationSamples
            free(const_cast<VkSampleMask *>(pStruct->pSampleMask));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
        {   // VkPipelineColorBlendStateCreateInfo
            VkPipelineColorBlendStateCreateInfo const *pStruct = static_cast<VkPipelineColorBlendStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineColorBlendAttachmentState - pAttachments / attachmentCount
            free(const_cast<VkPipelineColorBlendAttachmentState *>(pStruct->pAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
        {   // VkPipelineDynamicStateCreateInfo
            VkPipelineDynamicStateCreateInfo const *pStruct = static_cast<VkPipelineDynamicStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDynamicState - pDynamicStates / dynamicStateCount
            free(const_cast<VkDynamicState *>(pStruct->pDynamicStates));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
        {   // VkPipelineDepthStencilStateCreateInfo
            VkPipelineDepthStencilStateCreateInfo const *pStruct = static_cast<VkPipelineDepthStencilStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
        {   // VkGraphicsPipelineCreateInfo
            VkGraphicsPipelineCreateInfo const *pStruct = static_cast<VkGraphicsPipelineCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineShaderStageCreateInfo - pStages / stageCount
            for (uint32_t i = 0; i < pStruct->stageCount; ++i)
                vk_struct_cleanup(&pStruct->pStages[i]);
            free(const_cast<VkPipelineShaderStageCreateInfo *>(pStruct->pStages));

            // VkPipelineVertexInputStateCreateInfo - pVertexInputState
            vk_struct_cleanup(pStruct->pVertexInputState);
            free(const_cast<VkPipelineVertexInputStateCreateInfo *>(pStruct->pVertexInputState));

            // VkPipelineInputAssemblyStateCreateInfo - pInputAssemblyState
            vk_struct_cleanup(pStruct->pInputAssemblyState);
            free(const_cast<VkPipelineInputAssemblyStateCreateInfo *>(pStruct->pInputAssemblyState));

            // VkPipelineTessellationStateCreateInfo - pTessellationState
            vk_struct_cleanup(pStruct->pTessellationState);
            free(const_cast<VkPipelineTessellationStateCreateInfo *>(pStruct->pTessellationState));

            // VkPipelineViewportStateCreateInfo - pViewportState
            vk_struct_cleanup(pStruct->pViewportState);
            free(const_cast<VkPipelineViewportStateCreateInfo *>(pStruct->pViewportState));

            // VkPipelineRasterizationStateCreateInfo - pRasterizationState
            vk_struct_cleanup(pStruct->pRasterizationState);
            free(const_cast<VkPipelineRasterizationStateCreateInfo *>(pStruct->pRasterizationState));

            // VkPipelineMultisampleStateCreateInfo - pMultisampleState
            vk_struct_cleanup(pStruct->pMultisampleState);
            free(const_cast<VkPipelineMultisampleStateCreateInfo *>(pStruct->pMultisampleState));

            // VkPipelineDepthStencilStateCreateInfo - pDepthStencilState
            vk_struct_cleanup(pStruct->pDepthStencilState);
            free(const_cast<VkPipelineDepthStencilStateCreateInfo *>(pStruct->pDepthStencilState));

            // VkPipelineColorBlendStateCreateInfo - pColorBlendState
            vk_struct_cleanup(pStruct->pColorBlendState);
            free(const_cast<VkPipelineColorBlendStateCreateInfo *>(pStruct->pColorBlendState));

            // VkPipelineDynamicStateCreateInfo - pDynamicState
            vk_struct_cleanup(pStruct->pDynamicState);
            free(const_cast<VkPipelineDynamicStateCreateInfo *>(pStruct->pDynamicState));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
        {   // VkPipelineCacheCreateInfo
            VkPipelineCacheCreateInfo const *pStruct = static_cast<VkPipelineCacheCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pInitialData / initialDataSize
            free(const_cast<void *>(pStruct->pInitialData));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {   // VkPipelineLayoutCreateInfo
            VkPipelineLayoutCreateInfo const *pStruct = static_cast<VkPipelineLayoutCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorSetLayout - pSetLayouts / setLayoutCount
            free(const_cast<VkDescriptorSetLayout *>(pStruct->pSetLayouts));

            // VkPushConstantRange - pPushConstantRanges / pushConstantRangeCount
            free(const_cast<VkPushConstantRange *>(pStruct->pPushConstantRanges));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
        {   // VkSamplerCreateInfo
            VkSamplerCreateInfo const *pStruct = static_cast<VkSamplerCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
        {   // VkCommandPoolCreateInfo
            VkCommandPoolCreateInfo const *pStruct = static_cast<VkCommandPoolCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
        {   // VkCommandBufferAllocateInfo
            VkCommandBufferAllocateInfo const *pStruct = static_cast<VkCommandBufferAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
        {   // VkCommandBufferInheritanceInfo
            VkCommandBufferInheritanceInfo const *pStruct = static_cast<VkCommandBufferInheritanceInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
        {   // VkCommandBufferBeginInfo
            VkCommandBufferBeginInfo const *pStruct = static_cast<VkCommandBufferBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkCommandBufferInheritanceInfo - pInheritanceInfo
            vk_struct_cleanup(pStruct->pInheritanceInfo);
            free(const_cast<VkCommandBufferInheritanceInfo *>(pStruct->pInheritanceInfo));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
        {   // VkRenderPassBeginInfo
            VkRenderPassBeginInfo const *pStruct = static_cast<VkRenderPassBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkClearValue - pClearValues / clearValueCount
            free(const_cast<VkClearValue *>(pStruct->pClearValues));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
        {   // VkRenderPassCreateInfo
            VkRenderPassCreateInfo const *pStruct = static_cast<VkRenderPassCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentDescription - pAttachments / attachmentCount
            free(const_cast<VkAttachmentDescription *>(pStruct->pAttachments));

            // VkSubpassDescription - pSubpasses / subpassCount
            free(const_cast<VkSubpassDescription *>(pStruct->pSubpasses));

            // VkSubpassDependency - pDependencies / dependencyCount
            free(const_cast<VkSubpassDependency *>(pStruct->pDependencies));
        }

        break;

    case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
        {   // VkEventCreateInfo
            VkEventCreateInfo const *pStruct = static_cast<VkEventCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
        {   // VkFenceCreateInfo
            VkFenceCreateInfo const *pStruct = static_cast<VkFenceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
        {   // VkSemaphoreCreateInfo
            VkSemaphoreCreateInfo const *pStruct = static_cast<VkSemaphoreCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
        {   // VkQueryPoolCreateInfo
            VkQueryPoolCreateInfo const *pStruct = static_cast<VkQueryPoolCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
        {   // VkFramebufferCreateInfo
            VkFramebufferCreateInfo const *pStruct = static_cast<VkFramebufferCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageView - pAttachments / attachmentCount
            free(const_cast<VkImageView *>(pStruct->pAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBMIT_INFO:
        {   // VkSubmitInfo
            VkSubmitInfo const *pStruct = static_cast<VkSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pWaitSemaphores / waitSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pWaitSemaphores));

            // VkPipelineStageFlags - pWaitDstStageMask / waitSemaphoreCount
            free(const_cast<VkPipelineStageFlags *>(pStruct->pWaitDstStageMask));

            // VkCommandBuffer - pCommandBuffers / commandBufferCount
            free(const_cast<VkCommandBuffer *>(pStruct->pCommandBuffers));

            // VkSemaphore - pSignalSemaphores / signalSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pSignalSemaphores));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
        {   // VkDisplayModeCreateInfoKHR
            VkDisplayModeCreateInfoKHR const *pStruct = static_cast<VkDisplayModeCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
        {   // VkDisplaySurfaceCreateInfoKHR
            VkDisplaySurfaceCreateInfoKHR const *pStruct = static_cast<VkDisplaySurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {   // VkDisplayPresentInfoKHR
            VkDisplayPresentInfoKHR const *pStruct = static_cast<VkDisplayPresentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR:
        {   // VkAndroidSurfaceCreateInfoKHR
            VkAndroidSurfaceCreateInfoKHR const *pStruct = static_cast<VkAndroidSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_VI_NN
    case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN:
        {   // VkViSurfaceCreateInfoNN
            VkViSurfaceCreateInfoNN const *pStruct = static_cast<VkViSurfaceCreateInfoNN const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_VI_NN

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR:
        {   // VkWaylandSurfaceCreateInfoKHR
            VkWaylandSurfaceCreateInfoKHR const *pStruct = static_cast<VkWaylandSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR:
        {   // VkWin32SurfaceCreateInfoKHR
            VkWin32SurfaceCreateInfoKHR const *pStruct = static_cast<VkWin32SurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_XLIB_KHR
    case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
        {   // VkXlibSurfaceCreateInfoKHR
            VkXlibSurfaceCreateInfoKHR const *pStruct = static_cast<VkXlibSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
    case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
        {   // VkXcbSurfaceCreateInfoKHR
            VkXcbSurfaceCreateInfoKHR const *pStruct = static_cast<VkXcbSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA:
        {   // VkImagePipeSurfaceCreateInfoFUCHSIA
            VkImagePipeSurfaceCreateInfoFUCHSIA const *pStruct = static_cast<VkImagePipeSurfaceCreateInfoFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_GGP
    case VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
        {   // VkStreamDescriptorSurfaceCreateInfoGGP
            VkStreamDescriptorSurfaceCreateInfoGGP const *pStruct = static_cast<VkStreamDescriptorSurfaceCreateInfoGGP const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_GGP

    case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
        {   // VkSwapchainCreateInfoKHR
            VkSwapchainCreateInfoKHR const *pStruct = static_cast<VkSwapchainCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
        {   // VkPresentInfoKHR
            VkPresentInfoKHR const *pStruct = static_cast<VkPresentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pWaitSemaphores / waitSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pWaitSemaphores));

            // VkSwapchainKHR - pSwapchains / swapchainCount
            free(const_cast<VkSwapchainKHR *>(pStruct->pSwapchains));

            // uint32_t - pImageIndices / swapchainCount
            free(const_cast<uint32_t *>(pStruct->pImageIndices));

            // VkResult - pResults / swapchainCount
            free(const_cast<VkResult *>(pStruct->pResults));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {   // VkDebugReportCallbackCreateInfoEXT
            VkDebugReportCallbackCreateInfoEXT const *pStruct = static_cast<VkDebugReportCallbackCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {   // VkValidationFlagsEXT
            VkValidationFlagsEXT const *pStruct = static_cast<VkValidationFlagsEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkValidationCheckEXT - pDisabledValidationChecks / disabledValidationCheckCount
            free(const_cast<VkValidationCheckEXT *>(pStruct->pDisabledValidationChecks));
        }

        break;

    case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {   // VkValidationFeaturesEXT
            VkValidationFeaturesEXT const *pStruct = static_cast<VkValidationFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkValidationFeatureEnableEXT - pEnabledValidationFeatures / enabledValidationFeatureCount
            free(const_cast<VkValidationFeatureEnableEXT *>(pStruct->pEnabledValidationFeatures));

            // VkValidationFeatureDisableEXT - pDisabledValidationFeatures / disabledValidationFeatureCount
            free(const_cast<VkValidationFeatureDisableEXT *>(pStruct->pDisabledValidationFeatures));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {   // VkPipelineRasterizationStateRasterizationOrderAMD
            VkPipelineRasterizationStateRasterizationOrderAMD const *pStruct = static_cast<VkPipelineRasterizationStateRasterizationOrderAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
        {   // VkDebugMarkerObjectNameInfoEXT
            VkDebugMarkerObjectNameInfoEXT const *pStruct = static_cast<VkDebugMarkerObjectNameInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pObjectName / null-terminated
            free(const_cast<char *>(pStruct->pObjectName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
        {   // VkDebugMarkerObjectTagInfoEXT
            VkDebugMarkerObjectTagInfoEXT const *pStruct = static_cast<VkDebugMarkerObjectTagInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pTag / tagSize
            free(const_cast<void *>(pStruct->pTag));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
        {   // VkDebugMarkerMarkerInfoEXT
            VkDebugMarkerMarkerInfoEXT const *pStruct = static_cast<VkDebugMarkerMarkerInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pMarkerName / null-terminated
            free(const_cast<char *>(pStruct->pMarkerName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {   // VkDedicatedAllocationImageCreateInfoNV
            VkDedicatedAllocationImageCreateInfoNV const *pStruct = static_cast<VkDedicatedAllocationImageCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {   // VkDedicatedAllocationBufferCreateInfoNV
            VkDedicatedAllocationBufferCreateInfoNV const *pStruct = static_cast<VkDedicatedAllocationBufferCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {   // VkDedicatedAllocationMemoryAllocateInfoNV
            VkDedicatedAllocationMemoryAllocateInfoNV const *pStruct = static_cast<VkDedicatedAllocationMemoryAllocateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {   // VkExternalMemoryImageCreateInfoNV
            VkExternalMemoryImageCreateInfoNV const *pStruct = static_cast<VkExternalMemoryImageCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {   // VkExportMemoryAllocateInfoNV
            VkExportMemoryAllocateInfoNV const *pStruct = static_cast<VkExportMemoryAllocateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {   // VkImportMemoryWin32HandleInfoNV
            VkImportMemoryWin32HandleInfoNV const *pStruct = static_cast<VkImportMemoryWin32HandleInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {   // VkExportMemoryWin32HandleInfoNV
            VkExportMemoryWin32HandleInfoNV const *pStruct = static_cast<VkExportMemoryWin32HandleInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {   // VkWin32KeyedMutexAcquireReleaseInfoNV
            VkWin32KeyedMutexAcquireReleaseInfoNV const *pStruct = static_cast<VkWin32KeyedMutexAcquireReleaseInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDeviceMemory - pAcquireSyncs / acquireCount
            free(const_cast<VkDeviceMemory *>(pStruct->pAcquireSyncs));

            // uint64_t - pAcquireKeys / acquireCount
            free(const_cast<uint64_t *>(pStruct->pAcquireKeys));

            // uint32_t - pAcquireTimeoutMilliseconds / acquireCount
            free(const_cast<uint32_t *>(pStruct->pAcquireTimeoutMilliseconds));

            // VkDeviceMemory - pReleaseSyncs / releaseCount
            free(const_cast<VkDeviceMemory *>(pStruct->pReleaseSyncs));

            // uint64_t - pReleaseKeys / releaseCount
            free(const_cast<uint64_t *>(pStruct->pReleaseKeys));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX:
        {   // VkDeviceGeneratedCommandsFeaturesNVX
            VkDeviceGeneratedCommandsFeaturesNVX const *pStruct = static_cast<VkDeviceGeneratedCommandsFeaturesNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX:
        {   // VkDeviceGeneratedCommandsLimitsNVX
            VkDeviceGeneratedCommandsLimitsNVX const *pStruct = static_cast<VkDeviceGeneratedCommandsLimitsNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX:
        {   // VkIndirectCommandsLayoutCreateInfoNVX
            VkIndirectCommandsLayoutCreateInfoNVX const *pStruct = static_cast<VkIndirectCommandsLayoutCreateInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkIndirectCommandsLayoutTokenNVX - pTokens / tokenCount
            free(const_cast<VkIndirectCommandsLayoutTokenNVX *>(pStruct->pTokens));
        }

        break;

    case VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX:
        {   // VkCmdProcessCommandsInfoNVX
            VkCmdProcessCommandsInfoNVX const *pStruct = static_cast<VkCmdProcessCommandsInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkIndirectCommandsTokenNVX - pIndirectCommandsTokens / indirectCommandsTokenCount
            free(const_cast<VkIndirectCommandsTokenNVX *>(pStruct->pIndirectCommandsTokens));
        }

        break;

    case VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX:
        {   // VkCmdReserveSpaceForCommandsInfoNVX
            VkCmdReserveSpaceForCommandsInfoNVX const *pStruct = static_cast<VkCmdReserveSpaceForCommandsInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX:
        {   // VkObjectTableCreateInfoNVX
            VkObjectTableCreateInfoNVX const *pStruct = static_cast<VkObjectTableCreateInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkObjectEntryTypeNVX - pObjectEntryTypes / objectCount
            free(const_cast<VkObjectEntryTypeNVX *>(pStruct->pObjectEntryTypes));

            // uint32_t - pObjectEntryCounts / objectCount
            free(const_cast<uint32_t *>(pStruct->pObjectEntryCounts));

            // VkObjectEntryUsageFlagsNVX - pObjectEntryUsageFlags / objectCount
            free(const_cast<VkObjectEntryUsageFlagsNVX *>(pStruct->pObjectEntryUsageFlags));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {   // VkPhysicalDeviceFeatures2
            VkPhysicalDeviceFeatures2 const *pStruct = static_cast<VkPhysicalDeviceFeatures2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
        {   // VkPhysicalDeviceProperties2
            VkPhysicalDeviceProperties2 const *pStruct = static_cast<VkPhysicalDeviceProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
        {   // VkFormatProperties2
            VkFormatProperties2 const *pStruct = static_cast<VkFormatProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
        {   // VkImageFormatProperties2
            VkImageFormatProperties2 const *pStruct = static_cast<VkImageFormatProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
        {   // VkPhysicalDeviceImageFormatInfo2
            VkPhysicalDeviceImageFormatInfo2 const *pStruct = static_cast<VkPhysicalDeviceImageFormatInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
        {   // VkQueueFamilyProperties2
            VkQueueFamilyProperties2 const *pStruct = static_cast<VkQueueFamilyProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
        {   // VkPhysicalDeviceMemoryProperties2
            VkPhysicalDeviceMemoryProperties2 const *pStruct = static_cast<VkPhysicalDeviceMemoryProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
        {   // VkSparseImageFormatProperties2
            VkSparseImageFormatProperties2 const *pStruct = static_cast<VkSparseImageFormatProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
        {   // VkPhysicalDeviceSparseImageFormatInfo2
            VkPhysicalDeviceSparseImageFormatInfo2 const *pStruct = static_cast<VkPhysicalDeviceSparseImageFormatInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {   // VkPhysicalDevicePushDescriptorPropertiesKHR
            VkPhysicalDevicePushDescriptorPropertiesKHR const *pStruct = static_cast<VkPhysicalDevicePushDescriptorPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR:
        {   // VkPhysicalDeviceDriverPropertiesKHR
            VkPhysicalDeviceDriverPropertiesKHR const *pStruct = static_cast<VkPhysicalDeviceDriverPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {   // VkPresentRegionsKHR
            VkPresentRegionsKHR const *pStruct = static_cast<VkPresentRegionsKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPresentRegionKHR - pRegions / swapchainCount
            free(const_cast<VkPresentRegionKHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {   // VkPhysicalDeviceVariablePointersFeatures
            VkPhysicalDeviceVariablePointersFeatures const *pStruct = static_cast<VkPhysicalDeviceVariablePointersFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {   // VkPhysicalDeviceExternalImageFormatInfo
            VkPhysicalDeviceExternalImageFormatInfo const *pStruct = static_cast<VkPhysicalDeviceExternalImageFormatInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {   // VkExternalImageFormatProperties
            VkExternalImageFormatProperties const *pStruct = static_cast<VkExternalImageFormatProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
        {   // VkPhysicalDeviceExternalBufferInfo
            VkPhysicalDeviceExternalBufferInfo const *pStruct = static_cast<VkPhysicalDeviceExternalBufferInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
        {   // VkExternalBufferProperties
            VkExternalBufferProperties const *pStruct = static_cast<VkExternalBufferProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {   // VkPhysicalDeviceIDProperties
            VkPhysicalDeviceIDProperties const *pStruct = static_cast<VkPhysicalDeviceIDProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {   // VkExternalMemoryImageCreateInfo
            VkExternalMemoryImageCreateInfo const *pStruct = static_cast<VkExternalMemoryImageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {   // VkExternalMemoryBufferCreateInfo
            VkExternalMemoryBufferCreateInfo const *pStruct = static_cast<VkExternalMemoryBufferCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {   // VkExportMemoryAllocateInfo
            VkExportMemoryAllocateInfo const *pStruct = static_cast<VkExportMemoryAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {   // VkImportMemoryWin32HandleInfoKHR
            VkImportMemoryWin32HandleInfoKHR const *pStruct = static_cast<VkImportMemoryWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {   // VkExportMemoryWin32HandleInfoKHR
            VkExportMemoryWin32HandleInfoKHR const *pStruct = static_cast<VkExportMemoryWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR:
        {   // VkMemoryWin32HandlePropertiesKHR
            VkMemoryWin32HandlePropertiesKHR const *pStruct = static_cast<VkMemoryWin32HandlePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR:
        {   // VkMemoryGetWin32HandleInfoKHR
            VkMemoryGetWin32HandleInfoKHR const *pStruct = static_cast<VkMemoryGetWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {   // VkImportMemoryFdInfoKHR
            VkImportMemoryFdInfoKHR const *pStruct = static_cast<VkImportMemoryFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
        {   // VkMemoryFdPropertiesKHR
            VkMemoryFdPropertiesKHR const *pStruct = static_cast<VkMemoryFdPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
        {   // VkMemoryGetFdInfoKHR
            VkMemoryGetFdInfoKHR const *pStruct = static_cast<VkMemoryGetFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {   // VkWin32KeyedMutexAcquireReleaseInfoKHR
            VkWin32KeyedMutexAcquireReleaseInfoKHR const *pStruct = static_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDeviceMemory - pAcquireSyncs / acquireCount
            free(const_cast<VkDeviceMemory *>(pStruct->pAcquireSyncs));

            // uint64_t - pAcquireKeys / acquireCount
            free(const_cast<uint64_t *>(pStruct->pAcquireKeys));

            // uint32_t - pAcquireTimeouts / acquireCount
            free(const_cast<uint32_t *>(pStruct->pAcquireTimeouts));

            // VkDeviceMemory - pReleaseSyncs / releaseCount
            free(const_cast<VkDeviceMemory *>(pStruct->pReleaseSyncs));

            // uint64_t - pReleaseKeys / releaseCount
            free(const_cast<uint64_t *>(pStruct->pReleaseKeys));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
        {   // VkPhysicalDeviceExternalSemaphoreInfo
            VkPhysicalDeviceExternalSemaphoreInfo const *pStruct = static_cast<VkPhysicalDeviceExternalSemaphoreInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
        {   // VkExternalSemaphoreProperties
            VkExternalSemaphoreProperties const *pStruct = static_cast<VkExternalSemaphoreProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {   // VkExportSemaphoreCreateInfo
            VkExportSemaphoreCreateInfo const *pStruct = static_cast<VkExportSemaphoreCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {   // VkImportSemaphoreWin32HandleInfoKHR
            VkImportSemaphoreWin32HandleInfoKHR const *pStruct = static_cast<VkImportSemaphoreWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {   // VkExportSemaphoreWin32HandleInfoKHR
            VkExportSemaphoreWin32HandleInfoKHR const *pStruct = static_cast<VkExportSemaphoreWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {   // VkD3D12FenceSubmitInfoKHR
            VkD3D12FenceSubmitInfoKHR const *pStruct = static_cast<VkD3D12FenceSubmitInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint64_t - pWaitSemaphoreValues / waitSemaphoreValuesCount
            free(const_cast<uint64_t *>(pStruct->pWaitSemaphoreValues));

            // uint64_t - pSignalSemaphoreValues / signalSemaphoreValuesCount
            free(const_cast<uint64_t *>(pStruct->pSignalSemaphoreValues));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR:
        {   // VkSemaphoreGetWin32HandleInfoKHR
            VkSemaphoreGetWin32HandleInfoKHR const *pStruct = static_cast<VkSemaphoreGetWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
        {   // VkImportSemaphoreFdInfoKHR
            VkImportSemaphoreFdInfoKHR const *pStruct = static_cast<VkImportSemaphoreFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
        {   // VkSemaphoreGetFdInfoKHR
            VkSemaphoreGetFdInfoKHR const *pStruct = static_cast<VkSemaphoreGetFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
        {   // VkPhysicalDeviceExternalFenceInfo
            VkPhysicalDeviceExternalFenceInfo const *pStruct = static_cast<VkPhysicalDeviceExternalFenceInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
        {   // VkExternalFenceProperties
            VkExternalFenceProperties const *pStruct = static_cast<VkExternalFenceProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {   // VkExportFenceCreateInfo
            VkExportFenceCreateInfo const *pStruct = static_cast<VkExportFenceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {   // VkImportFenceWin32HandleInfoKHR
            VkImportFenceWin32HandleInfoKHR const *pStruct = static_cast<VkImportFenceWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {   // VkExportFenceWin32HandleInfoKHR
            VkExportFenceWin32HandleInfoKHR const *pStruct = static_cast<VkExportFenceWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
        {   // VkFenceGetWin32HandleInfoKHR
            VkFenceGetWin32HandleInfoKHR const *pStruct = static_cast<VkFenceGetWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
        {   // VkImportFenceFdInfoKHR
            VkImportFenceFdInfoKHR const *pStruct = static_cast<VkImportFenceFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
        {   // VkFenceGetFdInfoKHR
            VkFenceGetFdInfoKHR const *pStruct = static_cast<VkFenceGetFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {   // VkPhysicalDeviceMultiviewFeatures
            VkPhysicalDeviceMultiviewFeatures const *pStruct = static_cast<VkPhysicalDeviceMultiviewFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {   // VkPhysicalDeviceMultiviewProperties
            VkPhysicalDeviceMultiviewProperties const *pStruct = static_cast<VkPhysicalDeviceMultiviewProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {   // VkRenderPassMultiviewCreateInfo
            VkRenderPassMultiviewCreateInfo const *pStruct = static_cast<VkRenderPassMultiviewCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pViewMasks / subpassCount
            free(const_cast<uint32_t *>(pStruct->pViewMasks));

            // int32_t - pViewOffsets / dependencyCount
            free(const_cast<int32_t *>(pStruct->pViewOffsets));

            // uint32_t - pCorrelationMasks / correlationMaskCount
            free(const_cast<uint32_t *>(pStruct->pCorrelationMasks));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
        {   // VkSurfaceCapabilities2EXT
            VkSurfaceCapabilities2EXT const *pStruct = static_cast<VkSurfaceCapabilities2EXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
        {   // VkDisplayPowerInfoEXT
            VkDisplayPowerInfoEXT const *pStruct = static_cast<VkDisplayPowerInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
        {   // VkDeviceEventInfoEXT
            VkDeviceEventInfoEXT const *pStruct = static_cast<VkDeviceEventInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
        {   // VkDisplayEventInfoEXT
            VkDisplayEventInfoEXT const *pStruct = static_cast<VkDisplayEventInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {   // VkSwapchainCounterCreateInfoEXT
            VkSwapchainCounterCreateInfoEXT const *pStruct = static_cast<VkSwapchainCounterCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
        {   // VkPhysicalDeviceGroupProperties
            VkPhysicalDeviceGroupProperties const *pStruct = static_cast<VkPhysicalDeviceGroupProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {   // VkMemoryAllocateFlagsInfo
            VkMemoryAllocateFlagsInfo const *pStruct = static_cast<VkMemoryAllocateFlagsInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
        {   // VkBindBufferMemoryInfo
            VkBindBufferMemoryInfo const *pStruct = static_cast<VkBindBufferMemoryInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {   // VkBindBufferMemoryDeviceGroupInfo
            VkBindBufferMemoryDeviceGroupInfo const *pStruct = static_cast<VkBindBufferMemoryDeviceGroupInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceIndices / deviceIndexCount
            free(const_cast<uint32_t *>(pStruct->pDeviceIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
        {   // VkBindImageMemoryInfo
            VkBindImageMemoryInfo const *pStruct = static_cast<VkBindImageMemoryInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {   // VkBindImageMemoryDeviceGroupInfo
            VkBindImageMemoryDeviceGroupInfo const *pStruct = static_cast<VkBindImageMemoryDeviceGroupInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceIndices / deviceIndexCount
            free(const_cast<uint32_t *>(pStruct->pDeviceIndices));

            // VkRect2D - pSplitInstanceBindRegions / splitInstanceBindRegionCount
            free(const_cast<VkRect2D *>(pStruct->pSplitInstanceBindRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {   // VkDeviceGroupRenderPassBeginInfo
            VkDeviceGroupRenderPassBeginInfo const *pStruct = static_cast<VkDeviceGroupRenderPassBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkRect2D - pDeviceRenderAreas / deviceRenderAreaCount
            free(const_cast<VkRect2D *>(pStruct->pDeviceRenderAreas));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {   // VkDeviceGroupCommandBufferBeginInfo
            VkDeviceGroupCommandBufferBeginInfo const *pStruct = static_cast<VkDeviceGroupCommandBufferBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {   // VkDeviceGroupSubmitInfo
            VkDeviceGroupSubmitInfo const *pStruct = static_cast<VkDeviceGroupSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pWaitSemaphoreDeviceIndices / waitSemaphoreCount
            free(const_cast<uint32_t *>(pStruct->pWaitSemaphoreDeviceIndices));

            // uint32_t - pCommandBufferDeviceMasks / commandBufferCount
            free(const_cast<uint32_t *>(pStruct->pCommandBufferDeviceMasks));

            // uint32_t - pSignalSemaphoreDeviceIndices / signalSemaphoreCount
            free(const_cast<uint32_t *>(pStruct->pSignalSemaphoreDeviceIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {   // VkDeviceGroupBindSparseInfo
            VkDeviceGroupBindSparseInfo const *pStruct = static_cast<VkDeviceGroupBindSparseInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
        {   // VkDeviceGroupPresentCapabilitiesKHR
            VkDeviceGroupPresentCapabilitiesKHR const *pStruct = static_cast<VkDeviceGroupPresentCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {   // VkImageSwapchainCreateInfoKHR
            VkImageSwapchainCreateInfoKHR const *pStruct = static_cast<VkImageSwapchainCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {   // VkBindImageMemorySwapchainInfoKHR
            VkBindImageMemorySwapchainInfoKHR const *pStruct = static_cast<VkBindImageMemorySwapchainInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
        {   // VkAcquireNextImageInfoKHR
            VkAcquireNextImageInfoKHR const *pStruct = static_cast<VkAcquireNextImageInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {   // VkDeviceGroupPresentInfoKHR
            VkDeviceGroupPresentInfoKHR const *pStruct = static_cast<VkDeviceGroupPresentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceMasks / swapchainCount
            free(const_cast<uint32_t *>(pStruct->pDeviceMasks));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {   // VkDeviceGroupDeviceCreateInfo
            VkDeviceGroupDeviceCreateInfo const *pStruct = static_cast<VkDeviceGroupDeviceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPhysicalDevice - pPhysicalDevices / physicalDeviceCount
            free(const_cast<VkPhysicalDevice *>(pStruct->pPhysicalDevices));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {   // VkDeviceGroupSwapchainCreateInfoKHR
            VkDeviceGroupSwapchainCreateInfoKHR const *pStruct = static_cast<VkDeviceGroupSwapchainCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
        {   // VkDescriptorUpdateTemplateCreateInfo
            VkDescriptorUpdateTemplateCreateInfo const *pStruct = static_cast<VkDescriptorUpdateTemplateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorUpdateTemplateEntry - pDescriptorUpdateEntries / descriptorUpdateEntryCount
            free(const_cast<VkDescriptorUpdateTemplateEntry *>(pStruct->pDescriptorUpdateEntries));
        }

        break;

    case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
        {   // VkHdrMetadataEXT
            VkHdrMetadataEXT const *pStruct = static_cast<VkHdrMetadataEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {   // VkDisplayNativeHdrSurfaceCapabilitiesAMD
            VkDisplayNativeHdrSurfaceCapabilitiesAMD const *pStruct = static_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {   // VkSwapchainDisplayNativeHdrCreateInfoAMD
            VkSwapchainDisplayNativeHdrCreateInfoAMD const *pStruct = static_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {   // VkPresentTimesInfoGOOGLE
            VkPresentTimesInfoGOOGLE const *pStruct = static_cast<VkPresentTimesInfoGOOGLE const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPresentTimeGOOGLE - pTimes / swapchainCount
            free(const_cast<VkPresentTimeGOOGLE *>(pStruct->pTimes));
        }

        break;

#ifdef VK_USE_PLATFORM_IOS_MVK
    case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK:
        {   // VkIOSSurfaceCreateInfoMVK
            VkIOSSurfaceCreateInfoMVK const *pStruct = static_cast<VkIOSSurfaceCreateInfoMVK const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pView
            free(const_cast<void *>(pStruct->pView));
        }

        break;
#endif // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
    case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK:
        {   // VkMacOSSurfaceCreateInfoMVK
            VkMacOSSurfaceCreateInfoMVK const *pStruct = static_cast<VkMacOSSurfaceCreateInfoMVK const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pView
            free(const_cast<void *>(pStruct->pView));
        }

        break;
#endif // VK_USE_PLATFORM_MACOS_MVK

#ifdef VK_USE_PLATFORM_METAL_EXT
    case VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT:
        {   // VkMetalSurfaceCreateInfoEXT
            VkMetalSurfaceCreateInfoEXT const *pStruct = static_cast<VkMetalSurfaceCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // CAMetalLayer - pLayer
            free(const_cast<CAMetalLayer *>(pStruct->pLayer));
        }

        break;
#endif // VK_USE_PLATFORM_METAL_EXT

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportWScalingStateCreateInfoNV
            VkPipelineViewportWScalingStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportWScalingStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewportWScalingNV - pViewportWScalings / viewportCount
            free(const_cast<VkViewportWScalingNV *>(pStruct->pViewportWScalings));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportSwizzleStateCreateInfoNV
            VkPipelineViewportSwizzleStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportSwizzleStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewportSwizzleNV - pViewportSwizzles / viewportCount
            free(const_cast<VkViewportSwizzleNV *>(pStruct->pViewportSwizzles));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {   // VkPhysicalDeviceDiscardRectanglePropertiesEXT
            VkPhysicalDeviceDiscardRectanglePropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {   // VkPipelineDiscardRectangleStateCreateInfoEXT
            VkPipelineDiscardRectangleStateCreateInfoEXT const *pStruct = static_cast<VkPipelineDiscardRectangleStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkRect2D - pDiscardRectangles / discardRectangleCount
            free(const_cast<VkRect2D *>(pStruct->pDiscardRectangles));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {   // VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
            VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const *pStruct = static_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {   // VkRenderPassInputAttachmentAspectCreateInfo
            VkRenderPassInputAttachmentAspectCreateInfo const *pStruct = static_cast<VkRenderPassInputAttachmentAspectCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkInputAttachmentAspectReference - pAspectReferences / aspectReferenceCount
            free(const_cast<VkInputAttachmentAspectReference *>(pStruct->pAspectReferences));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
        {   // VkPhysicalDeviceSurfaceInfo2KHR
            VkPhysicalDeviceSurfaceInfo2KHR const *pStruct = static_cast<VkPhysicalDeviceSurfaceInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
        {   // VkSurfaceCapabilities2KHR
            VkSurfaceCapabilities2KHR const *pStruct = static_cast<VkSurfaceCapabilities2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
        {   // VkSurfaceFormat2KHR
            VkSurfaceFormat2KHR const *pStruct = static_cast<VkSurfaceFormat2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
        {   // VkDisplayProperties2KHR
            VkDisplayProperties2KHR const *pStruct = static_cast<VkDisplayProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
        {   // VkDisplayPlaneProperties2KHR
            VkDisplayPlaneProperties2KHR const *pStruct = static_cast<VkDisplayPlaneProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
        {   // VkDisplayModeProperties2KHR
            VkDisplayModeProperties2KHR const *pStruct = static_cast<VkDisplayModeProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
        {   // VkDisplayPlaneInfo2KHR
            VkDisplayPlaneInfo2KHR const *pStruct = static_cast<VkDisplayPlaneInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
        {   // VkDisplayPlaneCapabilities2KHR
            VkDisplayPlaneCapabilities2KHR const *pStruct = static_cast<VkDisplayPlaneCapabilities2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {   // VkSharedPresentSurfaceCapabilitiesKHR
            VkSharedPresentSurfaceCapabilitiesKHR const *pStruct = static_cast<VkSharedPresentSurfaceCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {   // VkPhysicalDevice16BitStorageFeatures
            VkPhysicalDevice16BitStorageFeatures const *pStruct = static_cast<VkPhysicalDevice16BitStorageFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {   // VkPhysicalDeviceSubgroupProperties
            VkPhysicalDeviceSubgroupProperties const *pStruct = static_cast<VkPhysicalDeviceSubgroupProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
        {   // VkBufferMemoryRequirementsInfo2
            VkBufferMemoryRequirementsInfo2 const *pStruct = static_cast<VkBufferMemoryRequirementsInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
        {   // VkImageMemoryRequirementsInfo2
            VkImageMemoryRequirementsInfo2 const *pStruct = static_cast<VkImageMemoryRequirementsInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
        {   // VkImageSparseMemoryRequirementsInfo2
            VkImageSparseMemoryRequirementsInfo2 const *pStruct = static_cast<VkImageSparseMemoryRequirementsInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
        {   // VkMemoryRequirements2
            VkMemoryRequirements2 const *pStruct = static_cast<VkMemoryRequirements2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
        {   // VkSparseImageMemoryRequirements2
            VkSparseImageMemoryRequirements2 const *pStruct = static_cast<VkSparseImageMemoryRequirements2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {   // VkPhysicalDevicePointClippingProperties
            VkPhysicalDevicePointClippingProperties const *pStruct = static_cast<VkPhysicalDevicePointClippingProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {   // VkMemoryDedicatedRequirements
            VkMemoryDedicatedRequirements const *pStruct = static_cast<VkMemoryDedicatedRequirements const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {   // VkMemoryDedicatedAllocateInfo
            VkMemoryDedicatedAllocateInfo const *pStruct = static_cast<VkMemoryDedicatedAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {   // VkImageViewUsageCreateInfo
            VkImageViewUsageCreateInfo const *pStruct = static_cast<VkImageViewUsageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {   // VkPipelineTessellationDomainOriginStateCreateInfo
            VkPipelineTessellationDomainOriginStateCreateInfo const *pStruct = static_cast<VkPipelineTessellationDomainOriginStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {   // VkSamplerYcbcrConversionInfo
            VkSamplerYcbcrConversionInfo const *pStruct = static_cast<VkSamplerYcbcrConversionInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
        {   // VkSamplerYcbcrConversionCreateInfo
            VkSamplerYcbcrConversionCreateInfo const *pStruct = static_cast<VkSamplerYcbcrConversionCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {   // VkBindImagePlaneMemoryInfo
            VkBindImagePlaneMemoryInfo const *pStruct = static_cast<VkBindImagePlaneMemoryInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {   // VkImagePlaneMemoryRequirementsInfo
            VkImagePlaneMemoryRequirementsInfo const *pStruct = static_cast<VkImagePlaneMemoryRequirementsInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {   // VkPhysicalDeviceSamplerYcbcrConversionFeatures
            VkPhysicalDeviceSamplerYcbcrConversionFeatures const *pStruct = static_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {   // VkSamplerYcbcrConversionImageFormatProperties
            VkSamplerYcbcrConversionImageFormatProperties const *pStruct = static_cast<VkSamplerYcbcrConversionImageFormatProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {   // VkTextureLODGatherFormatPropertiesAMD
            VkTextureLODGatherFormatPropertiesAMD const *pStruct = static_cast<VkTextureLODGatherFormatPropertiesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
        {   // VkConditionalRenderingBeginInfoEXT
            VkConditionalRenderingBeginInfoEXT const *pStruct = static_cast<VkConditionalRenderingBeginInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {   // VkProtectedSubmitInfo
            VkProtectedSubmitInfo const *pStruct = static_cast<VkProtectedSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {   // VkPhysicalDeviceProtectedMemoryFeatures
            VkPhysicalDeviceProtectedMemoryFeatures const *pStruct = static_cast<VkPhysicalDeviceProtectedMemoryFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {   // VkPhysicalDeviceProtectedMemoryProperties
            VkPhysicalDeviceProtectedMemoryProperties const *pStruct = static_cast<VkPhysicalDeviceProtectedMemoryProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
        {   // VkDeviceQueueInfo2
            VkDeviceQueueInfo2 const *pStruct = static_cast<VkDeviceQueueInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {   // VkPipelineCoverageToColorStateCreateInfoNV
            VkPipelineCoverageToColorStateCreateInfoNV const *pStruct = static_cast<VkPipelineCoverageToColorStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
        {   // VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
            VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {   // VkSampleLocationsInfoEXT
            VkSampleLocationsInfoEXT const *pStruct = static_cast<VkSampleLocationsInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSampleLocationEXT - pSampleLocations / sampleLocationsCount
            free(const_cast<VkSampleLocationEXT *>(pStruct->pSampleLocations));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {   // VkRenderPassSampleLocationsBeginInfoEXT
            VkRenderPassSampleLocationsBeginInfoEXT const *pStruct = static_cast<VkRenderPassSampleLocationsBeginInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentSampleLocationsEXT - pAttachmentInitialSampleLocations / attachmentInitialSampleLocationsCount
            free(const_cast<VkAttachmentSampleLocationsEXT *>(pStruct->pAttachmentInitialSampleLocations));

            // VkSubpassSampleLocationsEXT - pPostSubpassSampleLocations / postSubpassSampleLocationsCount
            free(const_cast<VkSubpassSampleLocationsEXT *>(pStruct->pPostSubpassSampleLocations));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {   // VkPipelineSampleLocationsStateCreateInfoEXT
            VkPipelineSampleLocationsStateCreateInfoEXT const *pStruct = static_cast<VkPipelineSampleLocationsStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {   // VkPhysicalDeviceSampleLocationsPropertiesEXT
            VkPhysicalDeviceSampleLocationsPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
        {   // VkMultisamplePropertiesEXT
            VkMultisamplePropertiesEXT const *pStruct = static_cast<VkMultisamplePropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
        {   // VkSamplerReductionModeCreateInfoEXT
            VkSamplerReductionModeCreateInfoEXT const *pStruct = static_cast<VkSamplerReductionModeCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {   // VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {   // VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {   // VkPipelineColorBlendAdvancedStateCreateInfoEXT
            VkPipelineColorBlendAdvancedStateCreateInfoEXT const *pStruct = static_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {   // VkPhysicalDeviceInlineUniformBlockFeaturesEXT
            VkPhysicalDeviceInlineUniformBlockFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {   // VkPhysicalDeviceInlineUniformBlockPropertiesEXT
            VkPhysicalDeviceInlineUniformBlockPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {   // VkWriteDescriptorSetInlineUniformBlockEXT
            VkWriteDescriptorSetInlineUniformBlockEXT const *pStruct = static_cast<VkWriteDescriptorSetInlineUniformBlockEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pData / dataSize
            free(const_cast<void *>(pStruct->pData));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {   // VkDescriptorPoolInlineUniformBlockCreateInfoEXT
            VkDescriptorPoolInlineUniformBlockCreateInfoEXT const *pStruct = static_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {   // VkPipelineCoverageModulationStateCreateInfoNV
            VkPipelineCoverageModulationStateCreateInfoNV const *pStruct = static_cast<VkPipelineCoverageModulationStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // float - pCoverageModulationTable / coverageModulationTableCount
            free(const_cast<float *>(pStruct->pCoverageModulationTable));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR:
        {   // VkImageFormatListCreateInfoKHR
            VkImageFormatListCreateInfoKHR const *pStruct = static_cast<VkImageFormatListCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkFormat - pViewFormats / viewFormatCount
            free(const_cast<VkFormat *>(pStruct->pViewFormats));
        }

        break;

    case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {   // VkValidationCacheCreateInfoEXT
            VkValidationCacheCreateInfoEXT const *pStruct = static_cast<VkValidationCacheCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pInitialData / initialDataSize
            free(const_cast<void *>(pStruct->pInitialData));
        }

        break;

    case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {   // VkShaderModuleValidationCacheCreateInfoEXT
            VkShaderModuleValidationCacheCreateInfoEXT const *pStruct = static_cast<VkShaderModuleValidationCacheCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {   // VkPhysicalDeviceMaintenance3Properties
            VkPhysicalDeviceMaintenance3Properties const *pStruct = static_cast<VkPhysicalDeviceMaintenance3Properties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
        {   // VkDescriptorSetLayoutSupport
            VkDescriptorSetLayoutSupport const *pStruct = static_cast<VkDescriptorSetLayoutSupport const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {   // VkPhysicalDeviceShaderDrawParametersFeatures
            VkPhysicalDeviceShaderDrawParametersFeatures const *pStruct = static_cast<VkPhysicalDeviceShaderDrawParametersFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR:
        {   // VkPhysicalDeviceFloat16Int8FeaturesKHR
            VkPhysicalDeviceFloat16Int8FeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceFloat16Int8FeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
        {   // VkPhysicalDeviceFloatControlsPropertiesKHR
            VkPhysicalDeviceFloatControlsPropertiesKHR const *pStruct = static_cast<VkPhysicalDeviceFloatControlsPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
        {   // VkPhysicalDeviceHostQueryResetFeaturesEXT
            VkPhysicalDeviceHostQueryResetFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceHostQueryResetFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {   // VkNativeBufferANDROID
            VkNativeBufferANDROID const *pStruct = static_cast<VkNativeBufferANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {   // VkDeviceQueueGlobalPriorityCreateInfoEXT
            VkDeviceQueueGlobalPriorityCreateInfoEXT const *pStruct = static_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {   // VkDebugUtilsObjectNameInfoEXT
            VkDebugUtilsObjectNameInfoEXT const *pStruct = static_cast<VkDebugUtilsObjectNameInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pObjectName / null-terminated
            free(const_cast<char *>(pStruct->pObjectName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
        {   // VkDebugUtilsObjectTagInfoEXT
            VkDebugUtilsObjectTagInfoEXT const *pStruct = static_cast<VkDebugUtilsObjectTagInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pTag / tagSize
            free(const_cast<void *>(pStruct->pTag));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
        {   // VkDebugUtilsLabelEXT
            VkDebugUtilsLabelEXT const *pStruct = static_cast<VkDebugUtilsLabelEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pLabelName / null-terminated
            free(const_cast<char *>(pStruct->pLabelName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {   // VkDebugUtilsMessengerCreateInfoEXT
            VkDebugUtilsMessengerCreateInfoEXT const *pStruct = static_cast<VkDebugUtilsMessengerCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
        {   // VkDebugUtilsMessengerCallbackDataEXT
            VkDebugUtilsMessengerCallbackDataEXT const *pStruct = static_cast<VkDebugUtilsMessengerCallbackDataEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pMessageIdName / null-terminated
            free(const_cast<char *>(pStruct->pMessageIdName));

            // char - pMessage / null-terminated
            free(const_cast<char *>(pStruct->pMessage));

            // VkDebugUtilsLabelEXT - pQueueLabels / queueLabelCount
            for (uint32_t i = 0; i < pStruct->queueLabelCount; ++i)
                vk_struct_cleanup(&pStruct->pQueueLabels[i]);
            free(const_cast<VkDebugUtilsLabelEXT *>(pStruct->pQueueLabels));

            // VkDebugUtilsLabelEXT - pCmdBufLabels / cmdBufLabelCount
            for (uint32_t i = 0; i < pStruct->cmdBufLabelCount; ++i)
                vk_struct_cleanup(&pStruct->pCmdBufLabels[i]);
            free(const_cast<VkDebugUtilsLabelEXT *>(pStruct->pCmdBufLabels));

            // VkDebugUtilsObjectNameInfoEXT - pObjects / objectCount
            for (uint32_t i = 0; i < pStruct->objectCount; ++i)
                vk_struct_cleanup(&pStruct->pObjects[i]);
            free(const_cast<VkDebugUtilsObjectNameInfoEXT *>(pStruct->pObjects));
        }

        break;

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {   // VkImportMemoryHostPointerInfoEXT
            VkImportMemoryHostPointerInfoEXT const *pStruct = static_cast<VkImportMemoryHostPointerInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pHostPointer
            free(const_cast<void *>(pStruct->pHostPointer));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
        {   // VkMemoryHostPointerPropertiesEXT
            VkMemoryHostPointerPropertiesEXT const *pStruct = static_cast<VkMemoryHostPointerPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {   // VkPhysicalDeviceExternalMemoryHostPropertiesEXT
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {   // VkPhysicalDeviceConservativeRasterizationPropertiesEXT
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
        {   // VkCalibratedTimestampInfoEXT
            VkCalibratedTimestampInfoEXT const *pStruct = static_cast<VkCalibratedTimestampInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {   // VkPhysicalDeviceShaderCorePropertiesAMD
            VkPhysicalDeviceShaderCorePropertiesAMD const *pStruct = static_cast<VkPhysicalDeviceShaderCorePropertiesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationConservativeStateCreateInfoEXT
            VkPipelineRasterizationConservativeStateCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
        {   // VkPhysicalDeviceDescriptorIndexingFeaturesEXT
            VkPhysicalDeviceDescriptorIndexingFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceDescriptorIndexingFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
        {   // VkPhysicalDeviceDescriptorIndexingPropertiesEXT
            VkPhysicalDeviceDescriptorIndexingPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceDescriptorIndexingPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
        {   // VkDescriptorSetLayoutBindingFlagsCreateInfoEXT
            VkDescriptorSetLayoutBindingFlagsCreateInfoEXT const *pStruct = static_cast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorBindingFlagsEXT - pBindingFlags / bindingCount
            free(const_cast<VkDescriptorBindingFlagsEXT *>(pStruct->pBindingFlags));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
        {   // VkDescriptorSetVariableDescriptorCountAllocateInfoEXT
            VkDescriptorSetVariableDescriptorCountAllocateInfoEXT const *pStruct = static_cast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDescriptorCounts / descriptorSetCount
            free(const_cast<uint32_t *>(pStruct->pDescriptorCounts));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
        {   // VkDescriptorSetVariableDescriptorCountLayoutSupportEXT
            VkDescriptorSetVariableDescriptorCountLayoutSupportEXT const *pStruct = static_cast<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR:
        {   // VkAttachmentDescription2KHR
            VkAttachmentDescription2KHR const *pStruct = static_cast<VkAttachmentDescription2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR:
        {   // VkAttachmentReference2KHR
            VkAttachmentReference2KHR const *pStruct = static_cast<VkAttachmentReference2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR:
        {   // VkSubpassDescription2KHR
            VkSubpassDescription2KHR const *pStruct = static_cast<VkSubpassDescription2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentReference2KHR - pInputAttachments / inputAttachmentCount
            for (uint32_t i = 0; i < pStruct->inputAttachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pInputAttachments[i]);
            free(const_cast<VkAttachmentReference2KHR *>(pStruct->pInputAttachments));

            // VkAttachmentReference2KHR - pColorAttachments / colorAttachmentCount
            for (uint32_t i = 0; i < pStruct->colorAttachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pColorAttachments[i]);
            free(const_cast<VkAttachmentReference2KHR *>(pStruct->pColorAttachments));

            // VkAttachmentReference2KHR - pResolveAttachments / colorAttachmentCount
            for (uint32_t i = 0; i < pStruct->colorAttachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pResolveAttachments[i]);
            free(const_cast<VkAttachmentReference2KHR *>(pStruct->pResolveAttachments));

            // VkAttachmentReference2KHR - pDepthStencilAttachment
            vk_struct_cleanup(pStruct->pDepthStencilAttachment);
            free(const_cast<VkAttachmentReference2KHR *>(pStruct->pDepthStencilAttachment));

            // uint32_t - pPreserveAttachments / preserveAttachmentCount
            free(const_cast<uint32_t *>(pStruct->pPreserveAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR:
        {   // VkSubpassDependency2KHR
            VkSubpassDependency2KHR const *pStruct = static_cast<VkSubpassDependency2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR:
        {   // VkRenderPassCreateInfo2KHR
            VkRenderPassCreateInfo2KHR const *pStruct = static_cast<VkRenderPassCreateInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentDescription2KHR - pAttachments / attachmentCount
            for (uint32_t i = 0; i < pStruct->attachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pAttachments[i]);
            free(const_cast<VkAttachmentDescription2KHR *>(pStruct->pAttachments));

            // VkSubpassDescription2KHR - pSubpasses / subpassCount
            for (uint32_t i = 0; i < pStruct->subpassCount; ++i)
                vk_struct_cleanup(&pStruct->pSubpasses[i]);
            free(const_cast<VkSubpassDescription2KHR *>(pStruct->pSubpasses));

            // VkSubpassDependency2KHR - pDependencies / dependencyCount
            for (uint32_t i = 0; i < pStruct->dependencyCount; ++i)
                vk_struct_cleanup(&pStruct->pDependencies[i]);
            free(const_cast<VkSubpassDependency2KHR *>(pStruct->pDependencies));

            // uint32_t - pCorrelatedViewMasks / correlatedViewMaskCount
            free(const_cast<uint32_t *>(pStruct->pCorrelatedViewMasks));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR:
        {   // VkSubpassBeginInfoKHR
            VkSubpassBeginInfoKHR const *pStruct = static_cast<VkSubpassBeginInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR:
        {   // VkSubpassEndInfoKHR
            VkSubpassEndInfoKHR const *pStruct = static_cast<VkSubpassEndInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {   // VkPipelineVertexInputDivisorStateCreateInfoEXT
            VkPipelineVertexInputDivisorStateCreateInfoEXT const *pStruct = static_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVertexInputBindingDivisorDescriptionEXT - pVertexBindingDivisors / vertexBindingDivisorCount
            free(const_cast<VkVertexInputBindingDivisorDescriptionEXT *>(pStruct->pVertexBindingDivisors));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {   // VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {   // VkPhysicalDevicePCIBusInfoPropertiesEXT
            VkPhysicalDevicePCIBusInfoPropertiesEXT const *pStruct = static_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {   // VkImportAndroidHardwareBufferInfoANDROID
            VkImportAndroidHardwareBufferInfoANDROID const *pStruct = static_cast<VkImportAndroidHardwareBufferInfoANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {   // VkAndroidHardwareBufferUsageANDROID
            VkAndroidHardwareBufferUsageANDROID const *pStruct = static_cast<VkAndroidHardwareBufferUsageANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
        {   // VkAndroidHardwareBufferPropertiesANDROID
            VkAndroidHardwareBufferPropertiesANDROID const *pStruct = static_cast<VkAndroidHardwareBufferPropertiesANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {   // VkMemoryGetAndroidHardwareBufferInfoANDROID
            VkMemoryGetAndroidHardwareBufferInfoANDROID const *pStruct = static_cast<VkMemoryGetAndroidHardwareBufferInfoANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {   // VkAndroidHardwareBufferFormatPropertiesANDROID
            VkAndroidHardwareBufferFormatPropertiesANDROID const *pStruct = static_cast<VkAndroidHardwareBufferFormatPropertiesANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {   // VkCommandBufferInheritanceConditionalRenderingInfoEXT
            VkCommandBufferInheritanceConditionalRenderingInfoEXT const *pStruct = static_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {   // VkExternalFormatANDROID
            VkExternalFormatANDROID const *pStruct = static_cast<VkExternalFormatANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
        {   // VkPhysicalDevice8BitStorageFeaturesKHR
            VkPhysicalDevice8BitStorageFeaturesKHR const *pStruct = static_cast<VkPhysicalDevice8BitStorageFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {   // VkPhysicalDeviceConditionalRenderingFeaturesEXT
            VkPhysicalDeviceConditionalRenderingFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
        {   // VkPhysicalDeviceVulkanMemoryModelFeaturesKHR
            VkPhysicalDeviceVulkanMemoryModelFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceVulkanMemoryModelFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
        {   // VkPhysicalDeviceShaderAtomicInt64FeaturesKHR
            VkPhysicalDeviceShaderAtomicInt64FeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceShaderAtomicInt64FeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {   // VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {   // VkQueueFamilyCheckpointPropertiesNV
            VkQueueFamilyCheckpointPropertiesNV const *pStruct = static_cast<VkQueueFamilyCheckpointPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
        {   // VkCheckpointDataNV
            VkCheckpointDataNV const *pStruct = static_cast<VkCheckpointDataNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pCheckpointMarker
            free(const_cast<void *>(pStruct->pCheckpointMarker));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
        {   // VkPhysicalDeviceDepthStencilResolvePropertiesKHR
            VkPhysicalDeviceDepthStencilResolvePropertiesKHR const *pStruct = static_cast<VkPhysicalDeviceDepthStencilResolvePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
        {   // VkSubpassDescriptionDepthStencilResolveKHR
            VkSubpassDescriptionDepthStencilResolveKHR const *pStruct = static_cast<VkSubpassDescriptionDepthStencilResolveKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentReference2KHR - pDepthStencilResolveAttachment
            vk_struct_cleanup(pStruct->pDepthStencilResolveAttachment);
            free(const_cast<VkAttachmentReference2KHR *>(pStruct->pDepthStencilResolveAttachment));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {   // VkImageViewASTCDecodeModeEXT
            VkImageViewASTCDecodeModeEXT const *pStruct = static_cast<VkImageViewASTCDecodeModeEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {   // VkPhysicalDeviceASTCDecodeFeaturesEXT
            VkPhysicalDeviceASTCDecodeFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {   // VkPhysicalDeviceTransformFeedbackFeaturesEXT
            VkPhysicalDeviceTransformFeedbackFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {   // VkPhysicalDeviceTransformFeedbackPropertiesEXT
            VkPhysicalDeviceTransformFeedbackPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationStateStreamCreateInfoEXT
            VkPipelineRasterizationStateStreamCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationStateStreamCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {   // VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {   // VkPipelineRepresentativeFragmentTestStateCreateInfoNV
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV const *pStruct = static_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {   // VkPhysicalDeviceExclusiveScissorFeaturesNV
            VkPhysicalDeviceExclusiveScissorFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportExclusiveScissorStateCreateInfoNV
            VkPipelineViewportExclusiveScissorStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkRect2D - pExclusiveScissors / exclusiveScissorCount
            free(const_cast<VkRect2D *>(pStruct->pExclusiveScissors));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {   // VkPhysicalDeviceCornerSampledImageFeaturesNV
            VkPhysicalDeviceCornerSampledImageFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {   // VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {   // VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {   // VkPhysicalDeviceShaderImageFootprintFeaturesNV
            VkPhysicalDeviceShaderImageFootprintFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {   // VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportShadingRateImageStateCreateInfoNV
            VkPipelineViewportShadingRateImageStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkShadingRatePaletteNV - pShadingRatePalettes / viewportCount
            free(const_cast<VkShadingRatePaletteNV *>(pStruct->pShadingRatePalettes));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {   // VkPhysicalDeviceShadingRateImageFeaturesNV
            VkPhysicalDeviceShadingRateImageFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceShadingRateImageFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {   // VkPhysicalDeviceShadingRateImagePropertiesNV
            VkPhysicalDeviceShadingRateImagePropertiesNV const *pStruct = static_cast<VkPhysicalDeviceShadingRateImagePropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
            VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkCoarseSampleOrderCustomNV - pCustomSampleOrders / customSampleOrderCount
            free(const_cast<VkCoarseSampleOrderCustomNV *>(pStruct->pCustomSampleOrders));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {   // VkPhysicalDeviceMeshShaderFeaturesNV
            VkPhysicalDeviceMeshShaderFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceMeshShaderFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {   // VkPhysicalDeviceMeshShaderPropertiesNV
            VkPhysicalDeviceMeshShaderPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceMeshShaderPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
        {   // VkRayTracingShaderGroupCreateInfoNV
            VkRayTracingShaderGroupCreateInfoNV const *pStruct = static_cast<VkRayTracingShaderGroupCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
        {   // VkRayTracingPipelineCreateInfoNV
            VkRayTracingPipelineCreateInfoNV const *pStruct = static_cast<VkRayTracingPipelineCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineShaderStageCreateInfo - pStages / stageCount
            for (uint32_t i = 0; i < pStruct->stageCount; ++i)
                vk_struct_cleanup(&pStruct->pStages[i]);
            free(const_cast<VkPipelineShaderStageCreateInfo *>(pStruct->pStages));

            // VkRayTracingShaderGroupCreateInfoNV - pGroups / groupCount
            for (uint32_t i = 0; i < pStruct->groupCount; ++i)
                vk_struct_cleanup(&pStruct->pGroups[i]);
            free(const_cast<VkRayTracingShaderGroupCreateInfoNV *>(pStruct->pGroups));
        }

        break;

    case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
        {   // VkGeometryTrianglesNV
            VkGeometryTrianglesNV const *pStruct = static_cast<VkGeometryTrianglesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
        {   // VkGeometryAABBNV
            VkGeometryAABBNV const *pStruct = static_cast<VkGeometryAABBNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GEOMETRY_NV:
        {   // VkGeometryNV
            VkGeometryNV const *pStruct = static_cast<VkGeometryNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
        {   // VkAccelerationStructureInfoNV
            VkAccelerationStructureInfoNV const *pStruct = static_cast<VkAccelerationStructureInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkGeometryNV - pGeometries / geometryCount
            for (uint32_t i = 0; i < pStruct->geometryCount; ++i)
                vk_struct_cleanup(&pStruct->pGeometries[i]);
            free(const_cast<VkGeometryNV *>(pStruct->pGeometries));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
        {   // VkAccelerationStructureCreateInfoNV
            VkAccelerationStructureCreateInfoNV const *pStruct = static_cast<VkAccelerationStructureCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
        {   // VkBindAccelerationStructureMemoryInfoNV
            VkBindAccelerationStructureMemoryInfoNV const *pStruct = static_cast<VkBindAccelerationStructureMemoryInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceIndices / deviceIndexCount
            free(const_cast<uint32_t *>(pStruct->pDeviceIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {   // VkWriteDescriptorSetAccelerationStructureNV
            VkWriteDescriptorSetAccelerationStructureNV const *pStruct = static_cast<VkWriteDescriptorSetAccelerationStructureNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAccelerationStructureNV - pAccelerationStructures / accelerationStructureCount
            free(const_cast<VkAccelerationStructureNV *>(pStruct->pAccelerationStructures));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
        {   // VkAccelerationStructureMemoryRequirementsInfoNV
            VkAccelerationStructureMemoryRequirementsInfoNV const *pStruct = static_cast<VkAccelerationStructureMemoryRequirementsInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {   // VkPhysicalDeviceRayTracingPropertiesNV
            VkPhysicalDeviceRayTracingPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceRayTracingPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {   // VkDrmFormatModifierPropertiesListEXT
            VkDrmFormatModifierPropertiesListEXT const *pStruct = static_cast<VkDrmFormatModifierPropertiesListEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDrmFormatModifierPropertiesEXT - pDrmFormatModifierProperties / drmFormatModifierCount
            free(const_cast<VkDrmFormatModifierPropertiesEXT *>(pStruct->pDrmFormatModifierProperties));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {   // VkPhysicalDeviceImageDrmFormatModifierInfoEXT
            VkPhysicalDeviceImageDrmFormatModifierInfoEXT const *pStruct = static_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {   // VkImageDrmFormatModifierListCreateInfoEXT
            VkImageDrmFormatModifierListCreateInfoEXT const *pStruct = static_cast<VkImageDrmFormatModifierListCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint64_t - pDrmFormatModifiers / drmFormatModifierCount
            free(const_cast<uint64_t *>(pStruct->pDrmFormatModifiers));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {   // VkImageDrmFormatModifierExplicitCreateInfoEXT
            VkImageDrmFormatModifierExplicitCreateInfoEXT const *pStruct = static_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSubresourceLayout - pPlaneLayouts / drmFormatModifierPlaneCount
            free(const_cast<VkSubresourceLayout *>(pStruct->pPlaneLayouts));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
        {   // VkImageDrmFormatModifierPropertiesEXT
            VkImageDrmFormatModifierPropertiesEXT const *pStruct = static_cast<VkImageDrmFormatModifierPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT:
        {   // VkImageStencilUsageCreateInfoEXT
            VkImageStencilUsageCreateInfoEXT const *pStruct = static_cast<VkImageStencilUsageCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {   // VkDeviceMemoryOverallocationCreateInfoAMD
            VkDeviceMemoryOverallocationCreateInfoAMD const *pStruct = static_cast<VkDeviceMemoryOverallocationCreateInfoAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {   // VkPhysicalDeviceFragmentDensityMapFeaturesEXT
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {   // VkPhysicalDeviceFragmentDensityMapPropertiesEXT
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {   // VkRenderPassFragmentDensityMapCreateInfoEXT
            VkRenderPassFragmentDensityMapCreateInfoEXT const *pStruct = static_cast<VkRenderPassFragmentDensityMapCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
        {   // VkPhysicalDeviceScalarBlockLayoutFeaturesEXT
            VkPhysicalDeviceScalarBlockLayoutFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceScalarBlockLayoutFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {   // VkSurfaceProtectedCapabilitiesKHR
            VkSurfaceProtectedCapabilitiesKHR const *pStruct = static_cast<VkSurfaceProtectedCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR:
        {   // VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
            VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {   // VkPhysicalDeviceDepthClipEnableFeaturesEXT
            VkPhysicalDeviceDepthClipEnableFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationDepthClipStateCreateInfoEXT
            VkPipelineRasterizationDepthClipStateCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {   // VkPhysicalDeviceMemoryBudgetPropertiesEXT
            VkPhysicalDeviceMemoryBudgetPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {   // VkPhysicalDeviceMemoryPriorityFeaturesEXT
            VkPhysicalDeviceMemoryPriorityFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {   // VkMemoryPriorityAllocateInfoEXT
            VkMemoryPriorityAllocateInfoEXT const *pStruct = static_cast<VkMemoryPriorityAllocateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {   // VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT:
        {   // VkBufferDeviceAddressInfoEXT
            VkBufferDeviceAddressInfoEXT const *pStruct = static_cast<VkBufferDeviceAddressInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {   // VkBufferDeviceAddressCreateInfoEXT
            VkBufferDeviceAddressCreateInfoEXT const *pStruct = static_cast<VkBufferDeviceAddressCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {   // VkPhysicalDeviceImageViewImageFormatInfoEXT
            VkPhysicalDeviceImageViewImageFormatInfoEXT const *pStruct = static_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {   // VkFilterCubicImageViewImageFormatPropertiesEXT
            VkFilterCubicImageViewImageFormatPropertiesEXT const *pStruct = static_cast<VkFilterCubicImageViewImageFormatPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
        {   // VkPhysicalDeviceImagelessFramebufferFeaturesKHR
            VkPhysicalDeviceImagelessFramebufferFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceImagelessFramebufferFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
        {   // VkFramebufferAttachmentsCreateInfoKHR
            VkFramebufferAttachmentsCreateInfoKHR const *pStruct = static_cast<VkFramebufferAttachmentsCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkFramebufferAttachmentImageInfoKHR - pAttachmentImageInfos / attachmentImageInfoCount
            for (uint32_t i = 0; i < pStruct->attachmentImageInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pAttachmentImageInfos[i]);
            free(const_cast<VkFramebufferAttachmentImageInfoKHR *>(pStruct->pAttachmentImageInfos));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR:
        {   // VkFramebufferAttachmentImageInfoKHR
            VkFramebufferAttachmentImageInfoKHR const *pStruct = static_cast<VkFramebufferAttachmentImageInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkFormat - pViewFormats / viewFormatCount
            free(const_cast<VkFormat *>(pStruct->pViewFormats));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR:
        {   // VkRenderPassAttachmentBeginInfoKHR
            VkRenderPassAttachmentBeginInfoKHR const *pStruct = static_cast<VkRenderPassAttachmentBeginInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageView - pAttachments / attachmentCount
            free(const_cast<VkImageView *>(pStruct->pAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {   // VkPhysicalDeviceCooperativeMatrixFeaturesNV
            VkPhysicalDeviceCooperativeMatrixFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {   // VkPhysicalDeviceCooperativeMatrixPropertiesNV
            VkPhysicalDeviceCooperativeMatrixPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {   // VkCooperativeMatrixPropertiesNV
            VkCooperativeMatrixPropertiesNV const *pStruct = static_cast<VkCooperativeMatrixPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {   // VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
        {   // VkImageViewHandleInfoNVX
            VkImageViewHandleInfoNVX const *pStruct = static_cast<VkImageViewHandleInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_GGP
    case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {   // VkPresentFrameTokenGGP
            VkPresentFrameTokenGGP const *pStruct = static_cast<VkPresentFrameTokenGGP const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_GGP

    case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {   // VkPipelineCreationFeedbackCreateInfoEXT
            VkPipelineCreationFeedbackCreateInfoEXT const *pStruct = static_cast<VkPipelineCreationFeedbackCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineCreationFeedbackEXT - pPipelineCreationFeedback
            free(const_cast<VkPipelineCreationFeedbackEXT *>(pStruct->pPipelineCreationFeedback));

            // VkPipelineCreationFeedbackEXT - pPipelineStageCreationFeedbacks / pipelineStageCreationFeedbackCount
            free(const_cast<VkPipelineCreationFeedbackEXT *>(pStruct->pPipelineStageCreationFeedbacks));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {   // VkSurfaceFullScreenExclusiveInfoEXT
            VkSurfaceFullScreenExclusiveInfoEXT const *pStruct = static_cast<VkSurfaceFullScreenExclusiveInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {   // VkSurfaceFullScreenExclusiveWin32InfoEXT
            VkSurfaceFullScreenExclusiveWin32InfoEXT const *pStruct = static_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {   // VkSurfaceCapabilitiesFullScreenExclusiveEXT
            VkSurfaceCapabilitiesFullScreenExclusiveEXT const *pStruct = static_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
        {   // VkHeadlessSurfaceCreateInfoEXT
            VkHeadlessSurfaceCreateInfoEXT const *pStruct = static_cast<VkHeadlessSurfaceCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {   // VkPhysicalDeviceCoverageReductionModeFeaturesNV
            VkPhysicalDeviceCoverageReductionModeFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {   // VkPipelineCoverageReductionStateCreateInfoNV
            VkPipelineCoverageReductionStateCreateInfoNV const *pStruct = static_cast<VkPipelineCoverageReductionStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
        {   // VkFramebufferMixedSamplesCombinationNV
            VkFramebufferMixedSamplesCombinationNV const *pStruct = static_cast<VkFramebufferMixedSamplesCombinationNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2_FEATURES_INTEL:
        {   // VkPhysicalDeviceShaderIntegerFunctions2INTEL
            VkPhysicalDeviceShaderIntegerFunctions2INTEL const *pStruct = static_cast<VkPhysicalDeviceShaderIntegerFunctions2INTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
        {   // VkInitializePerformanceApiInfoINTEL
            VkInitializePerformanceApiInfoINTEL const *pStruct = static_cast<VkInitializePerformanceApiInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL:
        {   // VkQueryPoolCreateInfoINTEL
            VkQueryPoolCreateInfoINTEL const *pStruct = static_cast<VkQueryPoolCreateInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
        {   // VkPerformanceMarkerInfoINTEL
            VkPerformanceMarkerInfoINTEL const *pStruct = static_cast<VkPerformanceMarkerInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
        {   // VkPerformanceStreamMarkerInfoINTEL
            VkPerformanceStreamMarkerInfoINTEL const *pStruct = static_cast<VkPerformanceStreamMarkerInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
        {   // VkPerformanceOverrideInfoINTEL
            VkPerformanceOverrideInfoINTEL const *pStruct = static_cast<VkPerformanceOverrideInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
        {   // VkPerformanceConfigurationAcquireInfoINTEL
            VkPerformanceConfigurationAcquireInfoINTEL const *pStruct = static_cast<VkPerformanceConfigurationAcquireInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {   // VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {   // VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {   // VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {   // VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {   // VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {   // VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
            VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;


    default:
        break;
    }
}

#endif // VK_STRUCT_CLEANUP_CONFIG_MAIN

#endif // VK_STRUCT_CLEANUP_V114_HPP
