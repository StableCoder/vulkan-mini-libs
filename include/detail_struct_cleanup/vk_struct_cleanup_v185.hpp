/*
    Copyright (C) 2020 George Cave - gcave@stablecoder.ca

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/*
    This file was auto-generated by the Vulkan mini-libs utility can be found at
    https://github.com/stablecoder/vulkan-mini-libs.git
    or
    https://git.stabletec.com/utilities/vulkan-mini-libs.git

    Check for an updated version anytime, or state concerns/bugs.
*/

#ifndef VK_STRUCT_CLEANUP_V185_HPP
#define VK_STRUCT_CLEANUP_V185_HPP

/*  USAGE:
    To use, include this header where the declarations for the boolean checks are required.

    On *ONE* compilation unit, include the definition of `#define VK_STRUCT_CLEANUP_CONFIG_MAIN`
    so that the definitions are compiled somewhere following the one definition rule.
*/

#include <vulkan/vulkan.h>

static_assert(VK_HEADER_VERSION == 185, "Incompatible VK_HEADER_VERSION!" );

/** @brief Cleans up a Vulkan sType-based structure of pointer data
 * @param pData Pointer to the struct to be cleaned up
 * 
 * This function is only to be called on Vulkan structures that *have* a VkStructureType
 * member 'sType'. Any pointer members that start with 'p[A-Z]' are assumed to be *owned*
 * by the struct and are themselves cleaned up recusrively, and then deleted.
 *
 * This means any other pointer members, or pointer to pointer members are not cleaned up
 * and would still require manual deletion.
 */
void vk_struct_cleanup(void const* pData);

#ifdef VK_STRUCT_CLEANUP_CONFIG_MAIN

#include <cstdlib>

void vk_struct_cleanup(void const *pData) {
    if (pData == nullptr)
        return;

    struct VkTempStruct {
        VkStructureType sType;
    };
    VkTempStruct const *pTemp = static_cast<VkTempStruct const *>(pData);

    switch (pTemp->sType) {
    case VK_STRUCTURE_TYPE_APPLICATION_INFO:
        {   // VkApplicationInfo
            VkApplicationInfo const *pStruct = static_cast<VkApplicationInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pApplicationName / null-terminated
            free(const_cast<char *>(pStruct->pApplicationName));

            // char - pEngineName / null-terminated
            free(const_cast<char *>(pStruct->pEngineName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
        {   // VkDeviceQueueCreateInfo
            VkDeviceQueueCreateInfo const *pStruct = static_cast<VkDeviceQueueCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // float - pQueuePriorities / queueCount
            free(const_cast<float *>(pStruct->pQueuePriorities));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
        {   // VkDeviceCreateInfo
            VkDeviceCreateInfo const *pStruct = static_cast<VkDeviceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDeviceQueueCreateInfo - pQueueCreateInfos / queueCreateInfoCount
            for (uint32_t i = 0; i < pStruct->queueCreateInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pQueueCreateInfos[i]);
            free(const_cast<VkDeviceQueueCreateInfo *>(pStruct->pQueueCreateInfos));

            // VkPhysicalDeviceFeatures - pEnabledFeatures
            free(const_cast<VkPhysicalDeviceFeatures *>(pStruct->pEnabledFeatures));
        }

        break;

    case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
        {   // VkInstanceCreateInfo
            VkInstanceCreateInfo const *pStruct = static_cast<VkInstanceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkApplicationInfo - pApplicationInfo
            vk_struct_cleanup(pStruct->pApplicationInfo);
            free(const_cast<VkApplicationInfo *>(pStruct->pApplicationInfo));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
        {   // VkMemoryAllocateInfo
            VkMemoryAllocateInfo const *pStruct = static_cast<VkMemoryAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
        {   // VkMappedMemoryRange
            VkMappedMemoryRange const *pStruct = static_cast<VkMappedMemoryRange const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
        {   // VkWriteDescriptorSet
            VkWriteDescriptorSet const *pStruct = static_cast<VkWriteDescriptorSet const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorImageInfo - pImageInfo / descriptorCount
            free(const_cast<VkDescriptorImageInfo *>(pStruct->pImageInfo));

            // VkDescriptorBufferInfo - pBufferInfo / descriptorCount
            free(const_cast<VkDescriptorBufferInfo *>(pStruct->pBufferInfo));

            // VkBufferView - pTexelBufferView / descriptorCount
            free(const_cast<VkBufferView *>(pStruct->pTexelBufferView));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
        {   // VkCopyDescriptorSet
            VkCopyDescriptorSet const *pStruct = static_cast<VkCopyDescriptorSet const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
        {   // VkBufferCreateInfo
            VkBufferCreateInfo const *pStruct = static_cast<VkBufferCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
        {   // VkBufferViewCreateInfo
            VkBufferViewCreateInfo const *pStruct = static_cast<VkBufferViewCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
        {   // VkMemoryBarrier
            VkMemoryBarrier const *pStruct = static_cast<VkMemoryBarrier const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
        {   // VkBufferMemoryBarrier
            VkBufferMemoryBarrier const *pStruct = static_cast<VkBufferMemoryBarrier const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
        {   // VkImageMemoryBarrier
            VkImageMemoryBarrier const *pStruct = static_cast<VkImageMemoryBarrier const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
        {   // VkImageCreateInfo
            VkImageCreateInfo const *pStruct = static_cast<VkImageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
        {   // VkImageViewCreateInfo
            VkImageViewCreateInfo const *pStruct = static_cast<VkImageViewCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
        {   // VkBindSparseInfo
            VkBindSparseInfo const *pStruct = static_cast<VkBindSparseInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pWaitSemaphores / waitSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pWaitSemaphores));

            // VkSparseBufferMemoryBindInfo - pBufferBinds / bufferBindCount
            free(const_cast<VkSparseBufferMemoryBindInfo *>(pStruct->pBufferBinds));

            // VkSparseImageOpaqueMemoryBindInfo - pImageOpaqueBinds / imageOpaqueBindCount
            free(const_cast<VkSparseImageOpaqueMemoryBindInfo *>(pStruct->pImageOpaqueBinds));

            // VkSparseImageMemoryBindInfo - pImageBinds / imageBindCount
            free(const_cast<VkSparseImageMemoryBindInfo *>(pStruct->pImageBinds));

            // VkSemaphore - pSignalSemaphores / signalSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pSignalSemaphores));
        }

        break;

    case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
        {   // VkShaderModuleCreateInfo
            VkShaderModuleCreateInfo const *pStruct = static_cast<VkShaderModuleCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pCode / codeSize
            free(const_cast<uint32_t *>(pStruct->pCode));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
        {   // VkDescriptorSetLayoutCreateInfo
            VkDescriptorSetLayoutCreateInfo const *pStruct = static_cast<VkDescriptorSetLayoutCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorSetLayoutBinding - pBindings / bindingCount
            free(const_cast<VkDescriptorSetLayoutBinding *>(pStruct->pBindings));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
        {   // VkDescriptorPoolCreateInfo
            VkDescriptorPoolCreateInfo const *pStruct = static_cast<VkDescriptorPoolCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorPoolSize - pPoolSizes / poolSizeCount
            free(const_cast<VkDescriptorPoolSize *>(pStruct->pPoolSizes));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
        {   // VkDescriptorSetAllocateInfo
            VkDescriptorSetAllocateInfo const *pStruct = static_cast<VkDescriptorSetAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorSetLayout - pSetLayouts / descriptorSetCount
            free(const_cast<VkDescriptorSetLayout *>(pStruct->pSetLayouts));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
        {   // VkPipelineShaderStageCreateInfo
            VkPipelineShaderStageCreateInfo const *pStruct = static_cast<VkPipelineShaderStageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pName / null-terminated
            free(const_cast<char *>(pStruct->pName));

            // VkSpecializationInfo - pSpecializationInfo
            free(const_cast<VkSpecializationInfo *>(pStruct->pSpecializationInfo));
        }

        break;

    case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
        {   // VkComputePipelineCreateInfo
            VkComputePipelineCreateInfo const *pStruct = static_cast<VkComputePipelineCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
        {   // VkPipelineVertexInputStateCreateInfo
            VkPipelineVertexInputStateCreateInfo const *pStruct = static_cast<VkPipelineVertexInputStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVertexInputBindingDescription - pVertexBindingDescriptions / vertexBindingDescriptionCount
            free(const_cast<VkVertexInputBindingDescription *>(pStruct->pVertexBindingDescriptions));

            // VkVertexInputAttributeDescription - pVertexAttributeDescriptions / vertexAttributeDescriptionCount
            free(const_cast<VkVertexInputAttributeDescription *>(pStruct->pVertexAttributeDescriptions));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
        {   // VkPipelineInputAssemblyStateCreateInfo
            VkPipelineInputAssemblyStateCreateInfo const *pStruct = static_cast<VkPipelineInputAssemblyStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
        {   // VkPipelineTessellationStateCreateInfo
            VkPipelineTessellationStateCreateInfo const *pStruct = static_cast<VkPipelineTessellationStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
        {   // VkPipelineViewportStateCreateInfo
            VkPipelineViewportStateCreateInfo const *pStruct = static_cast<VkPipelineViewportStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewport - pViewports / viewportCount
            free(const_cast<VkViewport *>(pStruct->pViewports));

            // VkRect2D - pScissors / scissorCount
            free(const_cast<VkRect2D *>(pStruct->pScissors));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
        {   // VkPipelineRasterizationStateCreateInfo
            VkPipelineRasterizationStateCreateInfo const *pStruct = static_cast<VkPipelineRasterizationStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
        {   // VkPipelineMultisampleStateCreateInfo
            VkPipelineMultisampleStateCreateInfo const *pStruct = static_cast<VkPipelineMultisampleStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSampleMask - pSampleMask / rasterizationSamples
            free(const_cast<VkSampleMask *>(pStruct->pSampleMask));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
        {   // VkPipelineColorBlendStateCreateInfo
            VkPipelineColorBlendStateCreateInfo const *pStruct = static_cast<VkPipelineColorBlendStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineColorBlendAttachmentState - pAttachments / attachmentCount
            free(const_cast<VkPipelineColorBlendAttachmentState *>(pStruct->pAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
        {   // VkPipelineDynamicStateCreateInfo
            VkPipelineDynamicStateCreateInfo const *pStruct = static_cast<VkPipelineDynamicStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDynamicState - pDynamicStates / dynamicStateCount
            free(const_cast<VkDynamicState *>(pStruct->pDynamicStates));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
        {   // VkPipelineDepthStencilStateCreateInfo
            VkPipelineDepthStencilStateCreateInfo const *pStruct = static_cast<VkPipelineDepthStencilStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
        {   // VkGraphicsPipelineCreateInfo
            VkGraphicsPipelineCreateInfo const *pStruct = static_cast<VkGraphicsPipelineCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineShaderStageCreateInfo - pStages / stageCount
            for (uint32_t i = 0; i < pStruct->stageCount; ++i)
                vk_struct_cleanup(&pStruct->pStages[i]);
            free(const_cast<VkPipelineShaderStageCreateInfo *>(pStruct->pStages));

            // VkPipelineVertexInputStateCreateInfo - pVertexInputState
            vk_struct_cleanup(pStruct->pVertexInputState);
            free(const_cast<VkPipelineVertexInputStateCreateInfo *>(pStruct->pVertexInputState));

            // VkPipelineInputAssemblyStateCreateInfo - pInputAssemblyState
            vk_struct_cleanup(pStruct->pInputAssemblyState);
            free(const_cast<VkPipelineInputAssemblyStateCreateInfo *>(pStruct->pInputAssemblyState));

            // VkPipelineTessellationStateCreateInfo - pTessellationState
            vk_struct_cleanup(pStruct->pTessellationState);
            free(const_cast<VkPipelineTessellationStateCreateInfo *>(pStruct->pTessellationState));

            // VkPipelineViewportStateCreateInfo - pViewportState
            vk_struct_cleanup(pStruct->pViewportState);
            free(const_cast<VkPipelineViewportStateCreateInfo *>(pStruct->pViewportState));

            // VkPipelineRasterizationStateCreateInfo - pRasterizationState
            vk_struct_cleanup(pStruct->pRasterizationState);
            free(const_cast<VkPipelineRasterizationStateCreateInfo *>(pStruct->pRasterizationState));

            // VkPipelineMultisampleStateCreateInfo - pMultisampleState
            vk_struct_cleanup(pStruct->pMultisampleState);
            free(const_cast<VkPipelineMultisampleStateCreateInfo *>(pStruct->pMultisampleState));

            // VkPipelineDepthStencilStateCreateInfo - pDepthStencilState
            vk_struct_cleanup(pStruct->pDepthStencilState);
            free(const_cast<VkPipelineDepthStencilStateCreateInfo *>(pStruct->pDepthStencilState));

            // VkPipelineColorBlendStateCreateInfo - pColorBlendState
            vk_struct_cleanup(pStruct->pColorBlendState);
            free(const_cast<VkPipelineColorBlendStateCreateInfo *>(pStruct->pColorBlendState));

            // VkPipelineDynamicStateCreateInfo - pDynamicState
            vk_struct_cleanup(pStruct->pDynamicState);
            free(const_cast<VkPipelineDynamicStateCreateInfo *>(pStruct->pDynamicState));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
        {   // VkPipelineCacheCreateInfo
            VkPipelineCacheCreateInfo const *pStruct = static_cast<VkPipelineCacheCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pInitialData / initialDataSize
            free(const_cast<void *>(pStruct->pInitialData));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
        {   // VkPipelineLayoutCreateInfo
            VkPipelineLayoutCreateInfo const *pStruct = static_cast<VkPipelineLayoutCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorSetLayout - pSetLayouts / setLayoutCount
            free(const_cast<VkDescriptorSetLayout *>(pStruct->pSetLayouts));

            // VkPushConstantRange - pPushConstantRanges / pushConstantRangeCount
            free(const_cast<VkPushConstantRange *>(pStruct->pPushConstantRanges));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
        {   // VkSamplerCreateInfo
            VkSamplerCreateInfo const *pStruct = static_cast<VkSamplerCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
        {   // VkCommandPoolCreateInfo
            VkCommandPoolCreateInfo const *pStruct = static_cast<VkCommandPoolCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
        {   // VkCommandBufferAllocateInfo
            VkCommandBufferAllocateInfo const *pStruct = static_cast<VkCommandBufferAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
        {   // VkCommandBufferInheritanceInfo
            VkCommandBufferInheritanceInfo const *pStruct = static_cast<VkCommandBufferInheritanceInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
        {   // VkCommandBufferBeginInfo
            VkCommandBufferBeginInfo const *pStruct = static_cast<VkCommandBufferBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkCommandBufferInheritanceInfo - pInheritanceInfo
            vk_struct_cleanup(pStruct->pInheritanceInfo);
            free(const_cast<VkCommandBufferInheritanceInfo *>(pStruct->pInheritanceInfo));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
        {   // VkRenderPassBeginInfo
            VkRenderPassBeginInfo const *pStruct = static_cast<VkRenderPassBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkClearValue - pClearValues / clearValueCount
            free(const_cast<VkClearValue *>(pStruct->pClearValues));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
        {   // VkRenderPassCreateInfo
            VkRenderPassCreateInfo const *pStruct = static_cast<VkRenderPassCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentDescription - pAttachments / attachmentCount
            free(const_cast<VkAttachmentDescription *>(pStruct->pAttachments));

            // VkSubpassDescription - pSubpasses / subpassCount
            free(const_cast<VkSubpassDescription *>(pStruct->pSubpasses));

            // VkSubpassDependency - pDependencies / dependencyCount
            free(const_cast<VkSubpassDependency *>(pStruct->pDependencies));
        }

        break;

    case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
        {   // VkEventCreateInfo
            VkEventCreateInfo const *pStruct = static_cast<VkEventCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
        {   // VkFenceCreateInfo
            VkFenceCreateInfo const *pStruct = static_cast<VkFenceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
        {   // VkSemaphoreCreateInfo
            VkSemaphoreCreateInfo const *pStruct = static_cast<VkSemaphoreCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
        {   // VkQueryPoolCreateInfo
            VkQueryPoolCreateInfo const *pStruct = static_cast<VkQueryPoolCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
        {   // VkFramebufferCreateInfo
            VkFramebufferCreateInfo const *pStruct = static_cast<VkFramebufferCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageView - pAttachments / attachmentCount
            free(const_cast<VkImageView *>(pStruct->pAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBMIT_INFO:
        {   // VkSubmitInfo
            VkSubmitInfo const *pStruct = static_cast<VkSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pWaitSemaphores / waitSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pWaitSemaphores));

            // VkPipelineStageFlags - pWaitDstStageMask / waitSemaphoreCount
            free(const_cast<VkPipelineStageFlags *>(pStruct->pWaitDstStageMask));

            // VkCommandBuffer - pCommandBuffers / commandBufferCount
            free(const_cast<VkCommandBuffer *>(pStruct->pCommandBuffers));

            // VkSemaphore - pSignalSemaphores / signalSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pSignalSemaphores));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
        {   // VkDisplayModeCreateInfoKHR
            VkDisplayModeCreateInfoKHR const *pStruct = static_cast<VkDisplayModeCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
        {   // VkDisplaySurfaceCreateInfoKHR
            VkDisplaySurfaceCreateInfoKHR const *pStruct = static_cast<VkDisplaySurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
        {   // VkDisplayPresentInfoKHR
            VkDisplayPresentInfoKHR const *pStruct = static_cast<VkDisplayPresentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR:
        {   // VkAndroidSurfaceCreateInfoKHR
            VkAndroidSurfaceCreateInfoKHR const *pStruct = static_cast<VkAndroidSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_VI_NN
    case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN:
        {   // VkViSurfaceCreateInfoNN
            VkViSurfaceCreateInfoNN const *pStruct = static_cast<VkViSurfaceCreateInfoNN const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_VI_NN

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR:
        {   // VkWaylandSurfaceCreateInfoKHR
            VkWaylandSurfaceCreateInfoKHR const *pStruct = static_cast<VkWaylandSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR:
        {   // VkWin32SurfaceCreateInfoKHR
            VkWin32SurfaceCreateInfoKHR const *pStruct = static_cast<VkWin32SurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_XLIB_KHR
    case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
        {   // VkXlibSurfaceCreateInfoKHR
            VkXlibSurfaceCreateInfoKHR const *pStruct = static_cast<VkXlibSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
    case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
        {   // VkXcbSurfaceCreateInfoKHR
            VkXcbSurfaceCreateInfoKHR const *pStruct = static_cast<VkXcbSurfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    case VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT:
        {   // VkDirectFBSurfaceCreateInfoEXT
            VkDirectFBSurfaceCreateInfoEXT const *pStruct = static_cast<VkDirectFBSurfaceCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_DIRECTFB_EXT

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA:
        {   // VkImagePipeSurfaceCreateInfoFUCHSIA
            VkImagePipeSurfaceCreateInfoFUCHSIA const *pStruct = static_cast<VkImagePipeSurfaceCreateInfoFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_GGP
    case VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
        {   // VkStreamDescriptorSurfaceCreateInfoGGP
            VkStreamDescriptorSurfaceCreateInfoGGP const *pStruct = static_cast<VkStreamDescriptorSurfaceCreateInfoGGP const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_GGP

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    case VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX:
        {   // VkScreenSurfaceCreateInfoQNX
            VkScreenSurfaceCreateInfoQNX const *pStruct = static_cast<VkScreenSurfaceCreateInfoQNX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_SCREEN_QNX

    case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
        {   // VkSwapchainCreateInfoKHR
            VkSwapchainCreateInfoKHR const *pStruct = static_cast<VkSwapchainCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
        {   // VkPresentInfoKHR
            VkPresentInfoKHR const *pStruct = static_cast<VkPresentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pWaitSemaphores / waitSemaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pWaitSemaphores));

            // VkSwapchainKHR - pSwapchains / swapchainCount
            free(const_cast<VkSwapchainKHR *>(pStruct->pSwapchains));

            // uint32_t - pImageIndices / swapchainCount
            free(const_cast<uint32_t *>(pStruct->pImageIndices));

            // VkResult - pResults / swapchainCount
            free(const_cast<VkResult *>(pStruct->pResults));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
        {   // VkDebugReportCallbackCreateInfoEXT
            VkDebugReportCallbackCreateInfoEXT const *pStruct = static_cast<VkDebugReportCallbackCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
        {   // VkValidationFlagsEXT
            VkValidationFlagsEXT const *pStruct = static_cast<VkValidationFlagsEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkValidationCheckEXT - pDisabledValidationChecks / disabledValidationCheckCount
            free(const_cast<VkValidationCheckEXT *>(pStruct->pDisabledValidationChecks));
        }

        break;

    case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
        {   // VkValidationFeaturesEXT
            VkValidationFeaturesEXT const *pStruct = static_cast<VkValidationFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkValidationFeatureEnableEXT - pEnabledValidationFeatures / enabledValidationFeatureCount
            free(const_cast<VkValidationFeatureEnableEXT *>(pStruct->pEnabledValidationFeatures));

            // VkValidationFeatureDisableEXT - pDisabledValidationFeatures / disabledValidationFeatureCount
            free(const_cast<VkValidationFeatureDisableEXT *>(pStruct->pDisabledValidationFeatures));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
        {   // VkPipelineRasterizationStateRasterizationOrderAMD
            VkPipelineRasterizationStateRasterizationOrderAMD const *pStruct = static_cast<VkPipelineRasterizationStateRasterizationOrderAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
        {   // VkDebugMarkerObjectNameInfoEXT
            VkDebugMarkerObjectNameInfoEXT const *pStruct = static_cast<VkDebugMarkerObjectNameInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pObjectName / null-terminated
            free(const_cast<char *>(pStruct->pObjectName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
        {   // VkDebugMarkerObjectTagInfoEXT
            VkDebugMarkerObjectTagInfoEXT const *pStruct = static_cast<VkDebugMarkerObjectTagInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pTag / tagSize
            free(const_cast<void *>(pStruct->pTag));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
        {   // VkDebugMarkerMarkerInfoEXT
            VkDebugMarkerMarkerInfoEXT const *pStruct = static_cast<VkDebugMarkerMarkerInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pMarkerName / null-terminated
            free(const_cast<char *>(pStruct->pMarkerName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
        {   // VkDedicatedAllocationImageCreateInfoNV
            VkDedicatedAllocationImageCreateInfoNV const *pStruct = static_cast<VkDedicatedAllocationImageCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
        {   // VkDedicatedAllocationBufferCreateInfoNV
            VkDedicatedAllocationBufferCreateInfoNV const *pStruct = static_cast<VkDedicatedAllocationBufferCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
        {   // VkDedicatedAllocationMemoryAllocateInfoNV
            VkDedicatedAllocationMemoryAllocateInfoNV const *pStruct = static_cast<VkDedicatedAllocationMemoryAllocateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
        {   // VkExternalMemoryImageCreateInfoNV
            VkExternalMemoryImageCreateInfoNV const *pStruct = static_cast<VkExternalMemoryImageCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
        {   // VkExportMemoryAllocateInfoNV
            VkExportMemoryAllocateInfoNV const *pStruct = static_cast<VkExportMemoryAllocateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {   // VkImportMemoryWin32HandleInfoNV
            VkImportMemoryWin32HandleInfoNV const *pStruct = static_cast<VkImportMemoryWin32HandleInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
        {   // VkExportMemoryWin32HandleInfoNV
            VkExportMemoryWin32HandleInfoNV const *pStruct = static_cast<VkExportMemoryWin32HandleInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
        {   // VkWin32KeyedMutexAcquireReleaseInfoNV
            VkWin32KeyedMutexAcquireReleaseInfoNV const *pStruct = static_cast<VkWin32KeyedMutexAcquireReleaseInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDeviceMemory - pAcquireSyncs / acquireCount
            free(const_cast<VkDeviceMemory *>(pStruct->pAcquireSyncs));

            // uint64_t - pAcquireKeys / acquireCount
            free(const_cast<uint64_t *>(pStruct->pAcquireKeys));

            // uint32_t - pAcquireTimeoutMilliseconds / acquireCount
            free(const_cast<uint32_t *>(pStruct->pAcquireTimeoutMilliseconds));

            // VkDeviceMemory - pReleaseSyncs / releaseCount
            free(const_cast<VkDeviceMemory *>(pStruct->pReleaseSyncs));

            // uint64_t - pReleaseKeys / releaseCount
            free(const_cast<uint64_t *>(pStruct->pReleaseKeys));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
        {   // VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
            VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT:
        {   // VkDevicePrivateDataCreateInfoEXT
            VkDevicePrivateDataCreateInfoEXT const *pStruct = static_cast<VkDevicePrivateDataCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT:
        {   // VkPrivateDataSlotCreateInfoEXT
            VkPrivateDataSlotCreateInfoEXT const *pStruct = static_cast<VkPrivateDataSlotCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
        {   // VkPhysicalDevicePrivateDataFeaturesEXT
            VkPhysicalDevicePrivateDataFeaturesEXT const *pStruct = static_cast<VkPhysicalDevicePrivateDataFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
        {   // VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
            VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
        {   // VkPhysicalDeviceMultiDrawPropertiesEXT
            VkPhysicalDeviceMultiDrawPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceMultiDrawPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV:
        {   // VkGraphicsShaderGroupCreateInfoNV
            VkGraphicsShaderGroupCreateInfoNV const *pStruct = static_cast<VkGraphicsShaderGroupCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineShaderStageCreateInfo - pStages / stageCount
            for (uint32_t i = 0; i < pStruct->stageCount; ++i)
                vk_struct_cleanup(&pStruct->pStages[i]);
            free(const_cast<VkPipelineShaderStageCreateInfo *>(pStruct->pStages));

            // VkPipelineVertexInputStateCreateInfo - pVertexInputState
            vk_struct_cleanup(pStruct->pVertexInputState);
            free(const_cast<VkPipelineVertexInputStateCreateInfo *>(pStruct->pVertexInputState));

            // VkPipelineTessellationStateCreateInfo - pTessellationState
            vk_struct_cleanup(pStruct->pTessellationState);
            free(const_cast<VkPipelineTessellationStateCreateInfo *>(pStruct->pTessellationState));
        }

        break;

    case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
        {   // VkGraphicsPipelineShaderGroupsCreateInfoNV
            VkGraphicsPipelineShaderGroupsCreateInfoNV const *pStruct = static_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkGraphicsShaderGroupCreateInfoNV - pGroups / groupCount
            for (uint32_t i = 0; i < pStruct->groupCount; ++i)
                vk_struct_cleanup(&pStruct->pGroups[i]);
            free(const_cast<VkGraphicsShaderGroupCreateInfoNV *>(pStruct->pGroups));

            // VkPipeline - pPipelines / pipelineCount
            free(const_cast<VkPipeline *>(pStruct->pPipelines));
        }

        break;

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV:
        {   // VkIndirectCommandsLayoutTokenNV
            VkIndirectCommandsLayoutTokenNV const *pStruct = static_cast<VkIndirectCommandsLayoutTokenNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkIndexType - pIndexTypes / indexTypeCount
            free(const_cast<VkIndexType *>(pStruct->pIndexTypes));

            // uint32_t - pIndexTypeValues / indexTypeCount
            free(const_cast<uint32_t *>(pStruct->pIndexTypeValues));
        }

        break;

    case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
        {   // VkIndirectCommandsLayoutCreateInfoNV
            VkIndirectCommandsLayoutCreateInfoNV const *pStruct = static_cast<VkIndirectCommandsLayoutCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkIndirectCommandsLayoutTokenNV - pTokens / tokenCount
            for (uint32_t i = 0; i < pStruct->tokenCount; ++i)
                vk_struct_cleanup(&pStruct->pTokens[i]);
            free(const_cast<VkIndirectCommandsLayoutTokenNV *>(pStruct->pTokens));

            // uint32_t - pStreamStrides / streamCount
            free(const_cast<uint32_t *>(pStruct->pStreamStrides));
        }

        break;

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV:
        {   // VkGeneratedCommandsInfoNV
            VkGeneratedCommandsInfoNV const *pStruct = static_cast<VkGeneratedCommandsInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkIndirectCommandsStreamNV - pStreams / streamCount
            free(const_cast<VkIndirectCommandsStreamNV *>(pStruct->pStreams));
        }

        break;

    case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
        {   // VkGeneratedCommandsMemoryRequirementsInfoNV
            VkGeneratedCommandsMemoryRequirementsInfoNV const *pStruct = static_cast<VkGeneratedCommandsMemoryRequirementsInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
        {   // VkPhysicalDeviceFeatures2
            VkPhysicalDeviceFeatures2 const *pStruct = static_cast<VkPhysicalDeviceFeatures2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
        {   // VkPhysicalDeviceProperties2
            VkPhysicalDeviceProperties2 const *pStruct = static_cast<VkPhysicalDeviceProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
        {   // VkFormatProperties2
            VkFormatProperties2 const *pStruct = static_cast<VkFormatProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
        {   // VkImageFormatProperties2
            VkImageFormatProperties2 const *pStruct = static_cast<VkImageFormatProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
        {   // VkPhysicalDeviceImageFormatInfo2
            VkPhysicalDeviceImageFormatInfo2 const *pStruct = static_cast<VkPhysicalDeviceImageFormatInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
        {   // VkQueueFamilyProperties2
            VkQueueFamilyProperties2 const *pStruct = static_cast<VkQueueFamilyProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
        {   // VkPhysicalDeviceMemoryProperties2
            VkPhysicalDeviceMemoryProperties2 const *pStruct = static_cast<VkPhysicalDeviceMemoryProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
        {   // VkSparseImageFormatProperties2
            VkSparseImageFormatProperties2 const *pStruct = static_cast<VkSparseImageFormatProperties2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
        {   // VkPhysicalDeviceSparseImageFormatInfo2
            VkPhysicalDeviceSparseImageFormatInfo2 const *pStruct = static_cast<VkPhysicalDeviceSparseImageFormatInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
        {   // VkPhysicalDevicePushDescriptorPropertiesKHR
            VkPhysicalDevicePushDescriptorPropertiesKHR const *pStruct = static_cast<VkPhysicalDevicePushDescriptorPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
        {   // VkPhysicalDeviceDriverProperties
            VkPhysicalDeviceDriverProperties const *pStruct = static_cast<VkPhysicalDeviceDriverProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
        {   // VkPresentRegionsKHR
            VkPresentRegionsKHR const *pStruct = static_cast<VkPresentRegionsKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPresentRegionKHR - pRegions / swapchainCount
            free(const_cast<VkPresentRegionKHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
        {   // VkPhysicalDeviceVariablePointersFeatures
            VkPhysicalDeviceVariablePointersFeatures const *pStruct = static_cast<VkPhysicalDeviceVariablePointersFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
        {   // VkPhysicalDeviceExternalImageFormatInfo
            VkPhysicalDeviceExternalImageFormatInfo const *pStruct = static_cast<VkPhysicalDeviceExternalImageFormatInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
        {   // VkExternalImageFormatProperties
            VkExternalImageFormatProperties const *pStruct = static_cast<VkExternalImageFormatProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
        {   // VkPhysicalDeviceExternalBufferInfo
            VkPhysicalDeviceExternalBufferInfo const *pStruct = static_cast<VkPhysicalDeviceExternalBufferInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
        {   // VkExternalBufferProperties
            VkExternalBufferProperties const *pStruct = static_cast<VkExternalBufferProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
        {   // VkPhysicalDeviceIDProperties
            VkPhysicalDeviceIDProperties const *pStruct = static_cast<VkPhysicalDeviceIDProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
        {   // VkExternalMemoryImageCreateInfo
            VkExternalMemoryImageCreateInfo const *pStruct = static_cast<VkExternalMemoryImageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
        {   // VkExternalMemoryBufferCreateInfo
            VkExternalMemoryBufferCreateInfo const *pStruct = static_cast<VkExternalMemoryBufferCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
        {   // VkExportMemoryAllocateInfo
            VkExportMemoryAllocateInfo const *pStruct = static_cast<VkExportMemoryAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {   // VkImportMemoryWin32HandleInfoKHR
            VkImportMemoryWin32HandleInfoKHR const *pStruct = static_cast<VkImportMemoryWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
        {   // VkExportMemoryWin32HandleInfoKHR
            VkExportMemoryWin32HandleInfoKHR const *pStruct = static_cast<VkExportMemoryWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
        {   // VkImportMemoryZirconHandleInfoFUCHSIA
            VkImportMemoryZirconHandleInfoFUCHSIA const *pStruct = static_cast<VkImportMemoryZirconHandleInfoFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA:
        {   // VkMemoryZirconHandlePropertiesFUCHSIA
            VkMemoryZirconHandlePropertiesFUCHSIA const *pStruct = static_cast<VkMemoryZirconHandlePropertiesFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA:
        {   // VkMemoryGetZirconHandleInfoFUCHSIA
            VkMemoryGetZirconHandleInfoFUCHSIA const *pStruct = static_cast<VkMemoryGetZirconHandleInfoFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR:
        {   // VkMemoryWin32HandlePropertiesKHR
            VkMemoryWin32HandlePropertiesKHR const *pStruct = static_cast<VkMemoryWin32HandlePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR:
        {   // VkMemoryGetWin32HandleInfoKHR
            VkMemoryGetWin32HandleInfoKHR const *pStruct = static_cast<VkMemoryGetWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
        {   // VkImportMemoryFdInfoKHR
            VkImportMemoryFdInfoKHR const *pStruct = static_cast<VkImportMemoryFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
        {   // VkMemoryFdPropertiesKHR
            VkMemoryFdPropertiesKHR const *pStruct = static_cast<VkMemoryFdPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
        {   // VkMemoryGetFdInfoKHR
            VkMemoryGetFdInfoKHR const *pStruct = static_cast<VkMemoryGetFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
        {   // VkWin32KeyedMutexAcquireReleaseInfoKHR
            VkWin32KeyedMutexAcquireReleaseInfoKHR const *pStruct = static_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDeviceMemory - pAcquireSyncs / acquireCount
            free(const_cast<VkDeviceMemory *>(pStruct->pAcquireSyncs));

            // uint64_t - pAcquireKeys / acquireCount
            free(const_cast<uint64_t *>(pStruct->pAcquireKeys));

            // uint32_t - pAcquireTimeouts / acquireCount
            free(const_cast<uint32_t *>(pStruct->pAcquireTimeouts));

            // VkDeviceMemory - pReleaseSyncs / releaseCount
            free(const_cast<VkDeviceMemory *>(pStruct->pReleaseSyncs));

            // uint64_t - pReleaseKeys / releaseCount
            free(const_cast<uint64_t *>(pStruct->pReleaseKeys));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
        {   // VkPhysicalDeviceExternalSemaphoreInfo
            VkPhysicalDeviceExternalSemaphoreInfo const *pStruct = static_cast<VkPhysicalDeviceExternalSemaphoreInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
        {   // VkExternalSemaphoreProperties
            VkExternalSemaphoreProperties const *pStruct = static_cast<VkExternalSemaphoreProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
        {   // VkExportSemaphoreCreateInfo
            VkExportSemaphoreCreateInfo const *pStruct = static_cast<VkExportSemaphoreCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {   // VkImportSemaphoreWin32HandleInfoKHR
            VkImportSemaphoreWin32HandleInfoKHR const *pStruct = static_cast<VkImportSemaphoreWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
        {   // VkExportSemaphoreWin32HandleInfoKHR
            VkExportSemaphoreWin32HandleInfoKHR const *pStruct = static_cast<VkExportSemaphoreWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
        {   // VkD3D12FenceSubmitInfoKHR
            VkD3D12FenceSubmitInfoKHR const *pStruct = static_cast<VkD3D12FenceSubmitInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint64_t - pWaitSemaphoreValues / waitSemaphoreValuesCount
            free(const_cast<uint64_t *>(pStruct->pWaitSemaphoreValues));

            // uint64_t - pSignalSemaphoreValues / signalSemaphoreValuesCount
            free(const_cast<uint64_t *>(pStruct->pSignalSemaphoreValues));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR:
        {   // VkSemaphoreGetWin32HandleInfoKHR
            VkSemaphoreGetWin32HandleInfoKHR const *pStruct = static_cast<VkSemaphoreGetWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
        {   // VkImportSemaphoreFdInfoKHR
            VkImportSemaphoreFdInfoKHR const *pStruct = static_cast<VkImportSemaphoreFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
        {   // VkSemaphoreGetFdInfoKHR
            VkSemaphoreGetFdInfoKHR const *pStruct = static_cast<VkSemaphoreGetFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA:
        {   // VkImportSemaphoreZirconHandleInfoFUCHSIA
            VkImportSemaphoreZirconHandleInfoFUCHSIA const *pStruct = static_cast<VkImportSemaphoreZirconHandleInfoFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
    case VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA:
        {   // VkSemaphoreGetZirconHandleInfoFUCHSIA
            VkSemaphoreGetZirconHandleInfoFUCHSIA const *pStruct = static_cast<VkSemaphoreGetZirconHandleInfoFUCHSIA const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_FUCHSIA

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
        {   // VkPhysicalDeviceExternalFenceInfo
            VkPhysicalDeviceExternalFenceInfo const *pStruct = static_cast<VkPhysicalDeviceExternalFenceInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
        {   // VkExternalFenceProperties
            VkExternalFenceProperties const *pStruct = static_cast<VkExternalFenceProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
        {   // VkExportFenceCreateInfo
            VkExportFenceCreateInfo const *pStruct = static_cast<VkExportFenceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {   // VkImportFenceWin32HandleInfoKHR
            VkImportFenceWin32HandleInfoKHR const *pStruct = static_cast<VkImportFenceWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
        {   // VkExportFenceWin32HandleInfoKHR
            VkExportFenceWin32HandleInfoKHR const *pStruct = static_cast<VkExportFenceWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // SECURITY_ATTRIBUTES - pAttributes
            free(const_cast<SECURITY_ATTRIBUTES *>(pStruct->pAttributes));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
        {   // VkFenceGetWin32HandleInfoKHR
            VkFenceGetWin32HandleInfoKHR const *pStruct = static_cast<VkFenceGetWin32HandleInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
        {   // VkImportFenceFdInfoKHR
            VkImportFenceFdInfoKHR const *pStruct = static_cast<VkImportFenceFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
        {   // VkFenceGetFdInfoKHR
            VkFenceGetFdInfoKHR const *pStruct = static_cast<VkFenceGetFdInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
        {   // VkPhysicalDeviceMultiviewFeatures
            VkPhysicalDeviceMultiviewFeatures const *pStruct = static_cast<VkPhysicalDeviceMultiviewFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
        {   // VkPhysicalDeviceMultiviewProperties
            VkPhysicalDeviceMultiviewProperties const *pStruct = static_cast<VkPhysicalDeviceMultiviewProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
        {   // VkRenderPassMultiviewCreateInfo
            VkRenderPassMultiviewCreateInfo const *pStruct = static_cast<VkRenderPassMultiviewCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pViewMasks / subpassCount
            free(const_cast<uint32_t *>(pStruct->pViewMasks));

            // int32_t - pViewOffsets / dependencyCount
            free(const_cast<int32_t *>(pStruct->pViewOffsets));

            // uint32_t - pCorrelationMasks / correlationMaskCount
            free(const_cast<uint32_t *>(pStruct->pCorrelationMasks));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
        {   // VkSurfaceCapabilities2EXT
            VkSurfaceCapabilities2EXT const *pStruct = static_cast<VkSurfaceCapabilities2EXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
        {   // VkDisplayPowerInfoEXT
            VkDisplayPowerInfoEXT const *pStruct = static_cast<VkDisplayPowerInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
        {   // VkDeviceEventInfoEXT
            VkDeviceEventInfoEXT const *pStruct = static_cast<VkDeviceEventInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
        {   // VkDisplayEventInfoEXT
            VkDisplayEventInfoEXT const *pStruct = static_cast<VkDisplayEventInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
        {   // VkSwapchainCounterCreateInfoEXT
            VkSwapchainCounterCreateInfoEXT const *pStruct = static_cast<VkSwapchainCounterCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
        {   // VkPhysicalDeviceGroupProperties
            VkPhysicalDeviceGroupProperties const *pStruct = static_cast<VkPhysicalDeviceGroupProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
        {   // VkMemoryAllocateFlagsInfo
            VkMemoryAllocateFlagsInfo const *pStruct = static_cast<VkMemoryAllocateFlagsInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
        {   // VkBindBufferMemoryInfo
            VkBindBufferMemoryInfo const *pStruct = static_cast<VkBindBufferMemoryInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
        {   // VkBindBufferMemoryDeviceGroupInfo
            VkBindBufferMemoryDeviceGroupInfo const *pStruct = static_cast<VkBindBufferMemoryDeviceGroupInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceIndices / deviceIndexCount
            free(const_cast<uint32_t *>(pStruct->pDeviceIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
        {   // VkBindImageMemoryInfo
            VkBindImageMemoryInfo const *pStruct = static_cast<VkBindImageMemoryInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
        {   // VkBindImageMemoryDeviceGroupInfo
            VkBindImageMemoryDeviceGroupInfo const *pStruct = static_cast<VkBindImageMemoryDeviceGroupInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceIndices / deviceIndexCount
            free(const_cast<uint32_t *>(pStruct->pDeviceIndices));

            // VkRect2D - pSplitInstanceBindRegions / splitInstanceBindRegionCount
            free(const_cast<VkRect2D *>(pStruct->pSplitInstanceBindRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
        {   // VkDeviceGroupRenderPassBeginInfo
            VkDeviceGroupRenderPassBeginInfo const *pStruct = static_cast<VkDeviceGroupRenderPassBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkRect2D - pDeviceRenderAreas / deviceRenderAreaCount
            free(const_cast<VkRect2D *>(pStruct->pDeviceRenderAreas));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
        {   // VkDeviceGroupCommandBufferBeginInfo
            VkDeviceGroupCommandBufferBeginInfo const *pStruct = static_cast<VkDeviceGroupCommandBufferBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
        {   // VkDeviceGroupSubmitInfo
            VkDeviceGroupSubmitInfo const *pStruct = static_cast<VkDeviceGroupSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pWaitSemaphoreDeviceIndices / waitSemaphoreCount
            free(const_cast<uint32_t *>(pStruct->pWaitSemaphoreDeviceIndices));

            // uint32_t - pCommandBufferDeviceMasks / commandBufferCount
            free(const_cast<uint32_t *>(pStruct->pCommandBufferDeviceMasks));

            // uint32_t - pSignalSemaphoreDeviceIndices / signalSemaphoreCount
            free(const_cast<uint32_t *>(pStruct->pSignalSemaphoreDeviceIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
        {   // VkDeviceGroupBindSparseInfo
            VkDeviceGroupBindSparseInfo const *pStruct = static_cast<VkDeviceGroupBindSparseInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
        {   // VkDeviceGroupPresentCapabilitiesKHR
            VkDeviceGroupPresentCapabilitiesKHR const *pStruct = static_cast<VkDeviceGroupPresentCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
        {   // VkImageSwapchainCreateInfoKHR
            VkImageSwapchainCreateInfoKHR const *pStruct = static_cast<VkImageSwapchainCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
        {   // VkBindImageMemorySwapchainInfoKHR
            VkBindImageMemorySwapchainInfoKHR const *pStruct = static_cast<VkBindImageMemorySwapchainInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
        {   // VkAcquireNextImageInfoKHR
            VkAcquireNextImageInfoKHR const *pStruct = static_cast<VkAcquireNextImageInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
        {   // VkDeviceGroupPresentInfoKHR
            VkDeviceGroupPresentInfoKHR const *pStruct = static_cast<VkDeviceGroupPresentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceMasks / swapchainCount
            free(const_cast<uint32_t *>(pStruct->pDeviceMasks));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
        {   // VkDeviceGroupDeviceCreateInfo
            VkDeviceGroupDeviceCreateInfo const *pStruct = static_cast<VkDeviceGroupDeviceCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPhysicalDevice - pPhysicalDevices / physicalDeviceCount
            free(const_cast<VkPhysicalDevice *>(pStruct->pPhysicalDevices));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
        {   // VkDeviceGroupSwapchainCreateInfoKHR
            VkDeviceGroupSwapchainCreateInfoKHR const *pStruct = static_cast<VkDeviceGroupSwapchainCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
        {   // VkDescriptorUpdateTemplateCreateInfo
            VkDescriptorUpdateTemplateCreateInfo const *pStruct = static_cast<VkDescriptorUpdateTemplateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorUpdateTemplateEntry - pDescriptorUpdateEntries / descriptorUpdateEntryCount
            free(const_cast<VkDescriptorUpdateTemplateEntry *>(pStruct->pDescriptorUpdateEntries));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
        {   // VkPhysicalDevicePresentIdFeaturesKHR
            VkPhysicalDevicePresentIdFeaturesKHR const *pStruct = static_cast<VkPhysicalDevicePresentIdFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
        {   // VkPresentIdKHR
            VkPresentIdKHR const *pStruct = static_cast<VkPresentIdKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint64_t - pPresentIds / swapchainCount
            free(const_cast<uint64_t *>(pStruct->pPresentIds));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
        {   // VkPhysicalDevicePresentWaitFeaturesKHR
            VkPhysicalDevicePresentWaitFeaturesKHR const *pStruct = static_cast<VkPhysicalDevicePresentWaitFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
        {   // VkHdrMetadataEXT
            VkHdrMetadataEXT const *pStruct = static_cast<VkHdrMetadataEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
        {   // VkDisplayNativeHdrSurfaceCapabilitiesAMD
            VkDisplayNativeHdrSurfaceCapabilitiesAMD const *pStruct = static_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
        {   // VkSwapchainDisplayNativeHdrCreateInfoAMD
            VkSwapchainDisplayNativeHdrCreateInfoAMD const *pStruct = static_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
        {   // VkPresentTimesInfoGOOGLE
            VkPresentTimesInfoGOOGLE const *pStruct = static_cast<VkPresentTimesInfoGOOGLE const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPresentTimeGOOGLE - pTimes / swapchainCount
            free(const_cast<VkPresentTimeGOOGLE *>(pStruct->pTimes));
        }

        break;

#ifdef VK_USE_PLATFORM_IOS_MVK
    case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK:
        {   // VkIOSSurfaceCreateInfoMVK
            VkIOSSurfaceCreateInfoMVK const *pStruct = static_cast<VkIOSSurfaceCreateInfoMVK const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pView
            free(const_cast<void *>(pStruct->pView));
        }

        break;
#endif // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
    case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK:
        {   // VkMacOSSurfaceCreateInfoMVK
            VkMacOSSurfaceCreateInfoMVK const *pStruct = static_cast<VkMacOSSurfaceCreateInfoMVK const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pView
            free(const_cast<void *>(pStruct->pView));
        }

        break;
#endif // VK_USE_PLATFORM_MACOS_MVK

#ifdef VK_USE_PLATFORM_METAL_EXT
    case VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT:
        {   // VkMetalSurfaceCreateInfoEXT
            VkMetalSurfaceCreateInfoEXT const *pStruct = static_cast<VkMetalSurfaceCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // CAMetalLayer - pLayer
            free(const_cast<CAMetalLayer *>(pStruct->pLayer));
        }

        break;
#endif // VK_USE_PLATFORM_METAL_EXT

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportWScalingStateCreateInfoNV
            VkPipelineViewportWScalingStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportWScalingStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewportWScalingNV - pViewportWScalings / viewportCount
            free(const_cast<VkViewportWScalingNV *>(pStruct->pViewportWScalings));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportSwizzleStateCreateInfoNV
            VkPipelineViewportSwizzleStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportSwizzleStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewportSwizzleNV - pViewportSwizzles / viewportCount
            free(const_cast<VkViewportSwizzleNV *>(pStruct->pViewportSwizzles));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
        {   // VkPhysicalDeviceDiscardRectanglePropertiesEXT
            VkPhysicalDeviceDiscardRectanglePropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
        {   // VkPipelineDiscardRectangleStateCreateInfoEXT
            VkPipelineDiscardRectangleStateCreateInfoEXT const *pStruct = static_cast<VkPipelineDiscardRectangleStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkRect2D - pDiscardRectangles / discardRectangleCount
            free(const_cast<VkRect2D *>(pStruct->pDiscardRectangles));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
        {   // VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
            VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const *pStruct = static_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
        {   // VkRenderPassInputAttachmentAspectCreateInfo
            VkRenderPassInputAttachmentAspectCreateInfo const *pStruct = static_cast<VkRenderPassInputAttachmentAspectCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkInputAttachmentAspectReference - pAspectReferences / aspectReferenceCount
            free(const_cast<VkInputAttachmentAspectReference *>(pStruct->pAspectReferences));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
        {   // VkPhysicalDeviceSurfaceInfo2KHR
            VkPhysicalDeviceSurfaceInfo2KHR const *pStruct = static_cast<VkPhysicalDeviceSurfaceInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
        {   // VkSurfaceCapabilities2KHR
            VkSurfaceCapabilities2KHR const *pStruct = static_cast<VkSurfaceCapabilities2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
        {   // VkSurfaceFormat2KHR
            VkSurfaceFormat2KHR const *pStruct = static_cast<VkSurfaceFormat2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
        {   // VkDisplayProperties2KHR
            VkDisplayProperties2KHR const *pStruct = static_cast<VkDisplayProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
        {   // VkDisplayPlaneProperties2KHR
            VkDisplayPlaneProperties2KHR const *pStruct = static_cast<VkDisplayPlaneProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
        {   // VkDisplayModeProperties2KHR
            VkDisplayModeProperties2KHR const *pStruct = static_cast<VkDisplayModeProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
        {   // VkDisplayPlaneInfo2KHR
            VkDisplayPlaneInfo2KHR const *pStruct = static_cast<VkDisplayPlaneInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
        {   // VkDisplayPlaneCapabilities2KHR
            VkDisplayPlaneCapabilities2KHR const *pStruct = static_cast<VkDisplayPlaneCapabilities2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
        {   // VkSharedPresentSurfaceCapabilitiesKHR
            VkSharedPresentSurfaceCapabilitiesKHR const *pStruct = static_cast<VkSharedPresentSurfaceCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
        {   // VkPhysicalDevice16BitStorageFeatures
            VkPhysicalDevice16BitStorageFeatures const *pStruct = static_cast<VkPhysicalDevice16BitStorageFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        {   // VkPhysicalDeviceSubgroupProperties
            VkPhysicalDeviceSubgroupProperties const *pStruct = static_cast<VkPhysicalDeviceSubgroupProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
        {   // VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
            VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures const *pStruct = static_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
        {   // VkBufferMemoryRequirementsInfo2
            VkBufferMemoryRequirementsInfo2 const *pStruct = static_cast<VkBufferMemoryRequirementsInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
        {   // VkImageMemoryRequirementsInfo2
            VkImageMemoryRequirementsInfo2 const *pStruct = static_cast<VkImageMemoryRequirementsInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
        {   // VkImageSparseMemoryRequirementsInfo2
            VkImageSparseMemoryRequirementsInfo2 const *pStruct = static_cast<VkImageSparseMemoryRequirementsInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
        {   // VkMemoryRequirements2
            VkMemoryRequirements2 const *pStruct = static_cast<VkMemoryRequirements2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
        {   // VkSparseImageMemoryRequirements2
            VkSparseImageMemoryRequirements2 const *pStruct = static_cast<VkSparseImageMemoryRequirements2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
        {   // VkPhysicalDevicePointClippingProperties
            VkPhysicalDevicePointClippingProperties const *pStruct = static_cast<VkPhysicalDevicePointClippingProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
        {   // VkMemoryDedicatedRequirements
            VkMemoryDedicatedRequirements const *pStruct = static_cast<VkMemoryDedicatedRequirements const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
        {   // VkMemoryDedicatedAllocateInfo
            VkMemoryDedicatedAllocateInfo const *pStruct = static_cast<VkMemoryDedicatedAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
        {   // VkImageViewUsageCreateInfo
            VkImageViewUsageCreateInfo const *pStruct = static_cast<VkImageViewUsageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
        {   // VkPipelineTessellationDomainOriginStateCreateInfo
            VkPipelineTessellationDomainOriginStateCreateInfo const *pStruct = static_cast<VkPipelineTessellationDomainOriginStateCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
        {   // VkSamplerYcbcrConversionInfo
            VkSamplerYcbcrConversionInfo const *pStruct = static_cast<VkSamplerYcbcrConversionInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
        {   // VkSamplerYcbcrConversionCreateInfo
            VkSamplerYcbcrConversionCreateInfo const *pStruct = static_cast<VkSamplerYcbcrConversionCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
        {   // VkBindImagePlaneMemoryInfo
            VkBindImagePlaneMemoryInfo const *pStruct = static_cast<VkBindImagePlaneMemoryInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
        {   // VkImagePlaneMemoryRequirementsInfo
            VkImagePlaneMemoryRequirementsInfo const *pStruct = static_cast<VkImagePlaneMemoryRequirementsInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
        {   // VkPhysicalDeviceSamplerYcbcrConversionFeatures
            VkPhysicalDeviceSamplerYcbcrConversionFeatures const *pStruct = static_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
        {   // VkSamplerYcbcrConversionImageFormatProperties
            VkSamplerYcbcrConversionImageFormatProperties const *pStruct = static_cast<VkSamplerYcbcrConversionImageFormatProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
        {   // VkTextureLODGatherFormatPropertiesAMD
            VkTextureLODGatherFormatPropertiesAMD const *pStruct = static_cast<VkTextureLODGatherFormatPropertiesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
        {   // VkConditionalRenderingBeginInfoEXT
            VkConditionalRenderingBeginInfoEXT const *pStruct = static_cast<VkConditionalRenderingBeginInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
        {   // VkProtectedSubmitInfo
            VkProtectedSubmitInfo const *pStruct = static_cast<VkProtectedSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        {   // VkPhysicalDeviceProtectedMemoryFeatures
            VkPhysicalDeviceProtectedMemoryFeatures const *pStruct = static_cast<VkPhysicalDeviceProtectedMemoryFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        {   // VkPhysicalDeviceProtectedMemoryProperties
            VkPhysicalDeviceProtectedMemoryProperties const *pStruct = static_cast<VkPhysicalDeviceProtectedMemoryProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
        {   // VkDeviceQueueInfo2
            VkDeviceQueueInfo2 const *pStruct = static_cast<VkDeviceQueueInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
        {   // VkPipelineCoverageToColorStateCreateInfoNV
            VkPipelineCoverageToColorStateCreateInfoNV const *pStruct = static_cast<VkPipelineCoverageToColorStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
        {   // VkPhysicalDeviceSamplerFilterMinmaxProperties
            VkPhysicalDeviceSamplerFilterMinmaxProperties const *pStruct = static_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
        {   // VkSampleLocationsInfoEXT
            VkSampleLocationsInfoEXT const *pStruct = static_cast<VkSampleLocationsInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSampleLocationEXT - pSampleLocations / sampleLocationsCount
            free(const_cast<VkSampleLocationEXT *>(pStruct->pSampleLocations));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
        {   // VkRenderPassSampleLocationsBeginInfoEXT
            VkRenderPassSampleLocationsBeginInfoEXT const *pStruct = static_cast<VkRenderPassSampleLocationsBeginInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentSampleLocationsEXT - pAttachmentInitialSampleLocations / attachmentInitialSampleLocationsCount
            free(const_cast<VkAttachmentSampleLocationsEXT *>(pStruct->pAttachmentInitialSampleLocations));

            // VkSubpassSampleLocationsEXT - pPostSubpassSampleLocations / postSubpassSampleLocationsCount
            free(const_cast<VkSubpassSampleLocationsEXT *>(pStruct->pPostSubpassSampleLocations));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
        {   // VkPipelineSampleLocationsStateCreateInfoEXT
            VkPipelineSampleLocationsStateCreateInfoEXT const *pStruct = static_cast<VkPipelineSampleLocationsStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
        {   // VkPhysicalDeviceSampleLocationsPropertiesEXT
            VkPhysicalDeviceSampleLocationsPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
        {   // VkMultisamplePropertiesEXT
            VkMultisamplePropertiesEXT const *pStruct = static_cast<VkMultisamplePropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
        {   // VkSamplerReductionModeCreateInfo
            VkSamplerReductionModeCreateInfo const *pStruct = static_cast<VkSamplerReductionModeCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
        {   // VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
            VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
        {   // VkPhysicalDeviceMultiDrawFeaturesEXT
            VkPhysicalDeviceMultiDrawFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceMultiDrawFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
        {   // VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
            VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
        {   // VkPipelineColorBlendAdvancedStateCreateInfoEXT
            VkPipelineColorBlendAdvancedStateCreateInfoEXT const *pStruct = static_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
        {   // VkPhysicalDeviceInlineUniformBlockFeaturesEXT
            VkPhysicalDeviceInlineUniformBlockFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
        {   // VkPhysicalDeviceInlineUniformBlockPropertiesEXT
            VkPhysicalDeviceInlineUniformBlockPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
        {   // VkWriteDescriptorSetInlineUniformBlockEXT
            VkWriteDescriptorSetInlineUniformBlockEXT const *pStruct = static_cast<VkWriteDescriptorSetInlineUniformBlockEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pData / dataSize
            free(const_cast<void *>(pStruct->pData));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
        {   // VkDescriptorPoolInlineUniformBlockCreateInfoEXT
            VkDescriptorPoolInlineUniformBlockCreateInfoEXT const *pStruct = static_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
        {   // VkPipelineCoverageModulationStateCreateInfoNV
            VkPipelineCoverageModulationStateCreateInfoNV const *pStruct = static_cast<VkPipelineCoverageModulationStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // float - pCoverageModulationTable / coverageModulationTableCount
            free(const_cast<float *>(pStruct->pCoverageModulationTable));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
        {   // VkImageFormatListCreateInfo
            VkImageFormatListCreateInfo const *pStruct = static_cast<VkImageFormatListCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkFormat - pViewFormats / viewFormatCount
            free(const_cast<VkFormat *>(pStruct->pViewFormats));
        }

        break;

    case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {   // VkValidationCacheCreateInfoEXT
            VkValidationCacheCreateInfoEXT const *pStruct = static_cast<VkValidationCacheCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pInitialData / initialDataSize
            free(const_cast<void *>(pStruct->pInitialData));
        }

        break;

    case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
        {   // VkShaderModuleValidationCacheCreateInfoEXT
            VkShaderModuleValidationCacheCreateInfoEXT const *pStruct = static_cast<VkShaderModuleValidationCacheCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
        {   // VkPhysicalDeviceMaintenance3Properties
            VkPhysicalDeviceMaintenance3Properties const *pStruct = static_cast<VkPhysicalDeviceMaintenance3Properties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
        {   // VkDescriptorSetLayoutSupport
            VkDescriptorSetLayoutSupport const *pStruct = static_cast<VkDescriptorSetLayoutSupport const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
        {   // VkPhysicalDeviceShaderDrawParametersFeatures
            VkPhysicalDeviceShaderDrawParametersFeatures const *pStruct = static_cast<VkPhysicalDeviceShaderDrawParametersFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
        {   // VkPhysicalDeviceShaderFloat16Int8Features
            VkPhysicalDeviceShaderFloat16Int8Features const *pStruct = static_cast<VkPhysicalDeviceShaderFloat16Int8Features const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
        {   // VkPhysicalDeviceFloatControlsProperties
            VkPhysicalDeviceFloatControlsProperties const *pStruct = static_cast<VkPhysicalDeviceFloatControlsProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
        {   // VkPhysicalDeviceHostQueryResetFeatures
            VkPhysicalDeviceHostQueryResetFeatures const *pStruct = static_cast<VkPhysicalDeviceHostQueryResetFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID:
        {   // VkNativeBufferANDROID
            VkNativeBufferANDROID const *pStruct = static_cast<VkNativeBufferANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID:
        {   // VkSwapchainImageCreateInfoANDROID
            VkSwapchainImageCreateInfoANDROID const *pStruct = static_cast<VkSwapchainImageCreateInfoANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID:
        {   // VkPhysicalDevicePresentationPropertiesANDROID
            VkPhysicalDevicePresentationPropertiesANDROID const *pStruct = static_cast<VkPhysicalDevicePresentationPropertiesANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

    case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
        {   // VkDeviceQueueGlobalPriorityCreateInfoEXT
            VkDeviceQueueGlobalPriorityCreateInfoEXT const *pStruct = static_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT:
        {   // VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
            VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT:
        {   // VkQueueFamilyGlobalPriorityPropertiesEXT
            VkQueueFamilyGlobalPriorityPropertiesEXT const *pStruct = static_cast<VkQueueFamilyGlobalPriorityPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
        {   // VkDebugUtilsObjectNameInfoEXT
            VkDebugUtilsObjectNameInfoEXT const *pStruct = static_cast<VkDebugUtilsObjectNameInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pObjectName / null-terminated
            free(const_cast<char *>(pStruct->pObjectName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
        {   // VkDebugUtilsObjectTagInfoEXT
            VkDebugUtilsObjectTagInfoEXT const *pStruct = static_cast<VkDebugUtilsObjectTagInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pTag / tagSize
            free(const_cast<void *>(pStruct->pTag));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
        {   // VkDebugUtilsLabelEXT
            VkDebugUtilsLabelEXT const *pStruct = static_cast<VkDebugUtilsLabelEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pLabelName / null-terminated
            free(const_cast<char *>(pStruct->pLabelName));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
        {   // VkDebugUtilsMessengerCreateInfoEXT
            VkDebugUtilsMessengerCreateInfoEXT const *pStruct = static_cast<VkDebugUtilsMessengerCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
        {   // VkDebugUtilsMessengerCallbackDataEXT
            VkDebugUtilsMessengerCallbackDataEXT const *pStruct = static_cast<VkDebugUtilsMessengerCallbackDataEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pMessageIdName / null-terminated
            free(const_cast<char *>(pStruct->pMessageIdName));

            // char - pMessage / null-terminated
            free(const_cast<char *>(pStruct->pMessage));

            // VkDebugUtilsLabelEXT - pQueueLabels / queueLabelCount
            for (uint32_t i = 0; i < pStruct->queueLabelCount; ++i)
                vk_struct_cleanup(&pStruct->pQueueLabels[i]);
            free(const_cast<VkDebugUtilsLabelEXT *>(pStruct->pQueueLabels));

            // VkDebugUtilsLabelEXT - pCmdBufLabels / cmdBufLabelCount
            for (uint32_t i = 0; i < pStruct->cmdBufLabelCount; ++i)
                vk_struct_cleanup(&pStruct->pCmdBufLabels[i]);
            free(const_cast<VkDebugUtilsLabelEXT *>(pStruct->pCmdBufLabels));

            // VkDebugUtilsObjectNameInfoEXT - pObjects / objectCount
            for (uint32_t i = 0; i < pStruct->objectCount; ++i)
                vk_struct_cleanup(&pStruct->pObjects[i]);
            free(const_cast<VkDebugUtilsObjectNameInfoEXT *>(pStruct->pObjects));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
        {   // VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
            VkPhysicalDeviceDeviceMemoryReportFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
        {   // VkDeviceDeviceMemoryReportCreateInfoEXT
            VkDeviceDeviceMemoryReportCreateInfoEXT const *pStruct = static_cast<VkDeviceDeviceMemoryReportCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
        {   // VkDeviceMemoryReportCallbackDataEXT
            VkDeviceMemoryReportCallbackDataEXT const *pStruct = static_cast<VkDeviceMemoryReportCallbackDataEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
        {   // VkImportMemoryHostPointerInfoEXT
            VkImportMemoryHostPointerInfoEXT const *pStruct = static_cast<VkImportMemoryHostPointerInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pHostPointer
            free(const_cast<void *>(pStruct->pHostPointer));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
        {   // VkMemoryHostPointerPropertiesEXT
            VkMemoryHostPointerPropertiesEXT const *pStruct = static_cast<VkMemoryHostPointerPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
        {   // VkPhysicalDeviceExternalMemoryHostPropertiesEXT
            VkPhysicalDeviceExternalMemoryHostPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
        {   // VkPhysicalDeviceConservativeRasterizationPropertiesEXT
            VkPhysicalDeviceConservativeRasterizationPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT:
        {   // VkCalibratedTimestampInfoEXT
            VkCalibratedTimestampInfoEXT const *pStruct = static_cast<VkCalibratedTimestampInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
        {   // VkPhysicalDeviceShaderCorePropertiesAMD
            VkPhysicalDeviceShaderCorePropertiesAMD const *pStruct = static_cast<VkPhysicalDeviceShaderCorePropertiesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
        {   // VkPhysicalDeviceShaderCoreProperties2AMD
            VkPhysicalDeviceShaderCoreProperties2AMD const *pStruct = static_cast<VkPhysicalDeviceShaderCoreProperties2AMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationConservativeStateCreateInfoEXT
            VkPipelineRasterizationConservativeStateCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
        {   // VkPhysicalDeviceDescriptorIndexingFeatures
            VkPhysicalDeviceDescriptorIndexingFeatures const *pStruct = static_cast<VkPhysicalDeviceDescriptorIndexingFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
        {   // VkPhysicalDeviceDescriptorIndexingProperties
            VkPhysicalDeviceDescriptorIndexingProperties const *pStruct = static_cast<VkPhysicalDeviceDescriptorIndexingProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
        {   // VkDescriptorSetLayoutBindingFlagsCreateInfo
            VkDescriptorSetLayoutBindingFlagsCreateInfo const *pStruct = static_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDescriptorBindingFlags - pBindingFlags / bindingCount
            free(const_cast<VkDescriptorBindingFlags *>(pStruct->pBindingFlags));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
        {   // VkDescriptorSetVariableDescriptorCountAllocateInfo
            VkDescriptorSetVariableDescriptorCountAllocateInfo const *pStruct = static_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDescriptorCounts / descriptorSetCount
            free(const_cast<uint32_t *>(pStruct->pDescriptorCounts));
        }

        break;

    case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
        {   // VkDescriptorSetVariableDescriptorCountLayoutSupport
            VkDescriptorSetVariableDescriptorCountLayoutSupport const *pStruct = static_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:
        {   // VkAttachmentDescription2
            VkAttachmentDescription2 const *pStruct = static_cast<VkAttachmentDescription2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:
        {   // VkAttachmentReference2
            VkAttachmentReference2 const *pStruct = static_cast<VkAttachmentReference2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:
        {   // VkSubpassDescription2
            VkSubpassDescription2 const *pStruct = static_cast<VkSubpassDescription2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentReference2 - pInputAttachments / inputAttachmentCount
            for (uint32_t i = 0; i < pStruct->inputAttachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pInputAttachments[i]);
            free(const_cast<VkAttachmentReference2 *>(pStruct->pInputAttachments));

            // VkAttachmentReference2 - pColorAttachments / colorAttachmentCount
            for (uint32_t i = 0; i < pStruct->colorAttachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pColorAttachments[i]);
            free(const_cast<VkAttachmentReference2 *>(pStruct->pColorAttachments));

            // VkAttachmentReference2 - pResolveAttachments / colorAttachmentCount
            for (uint32_t i = 0; i < pStruct->colorAttachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pResolveAttachments[i]);
            free(const_cast<VkAttachmentReference2 *>(pStruct->pResolveAttachments));

            // VkAttachmentReference2 - pDepthStencilAttachment
            vk_struct_cleanup(pStruct->pDepthStencilAttachment);
            free(const_cast<VkAttachmentReference2 *>(pStruct->pDepthStencilAttachment));

            // uint32_t - pPreserveAttachments / preserveAttachmentCount
            free(const_cast<uint32_t *>(pStruct->pPreserveAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:
        {   // VkSubpassDependency2
            VkSubpassDependency2 const *pStruct = static_cast<VkSubpassDependency2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
        {   // VkRenderPassCreateInfo2
            VkRenderPassCreateInfo2 const *pStruct = static_cast<VkRenderPassCreateInfo2 const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentDescription2 - pAttachments / attachmentCount
            for (uint32_t i = 0; i < pStruct->attachmentCount; ++i)
                vk_struct_cleanup(&pStruct->pAttachments[i]);
            free(const_cast<VkAttachmentDescription2 *>(pStruct->pAttachments));

            // VkSubpassDescription2 - pSubpasses / subpassCount
            for (uint32_t i = 0; i < pStruct->subpassCount; ++i)
                vk_struct_cleanup(&pStruct->pSubpasses[i]);
            free(const_cast<VkSubpassDescription2 *>(pStruct->pSubpasses));

            // VkSubpassDependency2 - pDependencies / dependencyCount
            for (uint32_t i = 0; i < pStruct->dependencyCount; ++i)
                vk_struct_cleanup(&pStruct->pDependencies[i]);
            free(const_cast<VkSubpassDependency2 *>(pStruct->pDependencies));

            // uint32_t - pCorrelatedViewMasks / correlatedViewMaskCount
            free(const_cast<uint32_t *>(pStruct->pCorrelatedViewMasks));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:
        {   // VkSubpassBeginInfo
            VkSubpassBeginInfo const *pStruct = static_cast<VkSubpassBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_END_INFO:
        {   // VkSubpassEndInfo
            VkSubpassEndInfo const *pStruct = static_cast<VkSubpassEndInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
        {   // VkPhysicalDeviceTimelineSemaphoreFeatures
            VkPhysicalDeviceTimelineSemaphoreFeatures const *pStruct = static_cast<VkPhysicalDeviceTimelineSemaphoreFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
        {   // VkPhysicalDeviceTimelineSemaphoreProperties
            VkPhysicalDeviceTimelineSemaphoreProperties const *pStruct = static_cast<VkPhysicalDeviceTimelineSemaphoreProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
        {   // VkSemaphoreTypeCreateInfo
            VkSemaphoreTypeCreateInfo const *pStruct = static_cast<VkSemaphoreTypeCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
        {   // VkTimelineSemaphoreSubmitInfo
            VkTimelineSemaphoreSubmitInfo const *pStruct = static_cast<VkTimelineSemaphoreSubmitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint64_t - pWaitSemaphoreValues / waitSemaphoreValueCount
            free(const_cast<uint64_t *>(pStruct->pWaitSemaphoreValues));

            // uint64_t - pSignalSemaphoreValues / signalSemaphoreValueCount
            free(const_cast<uint64_t *>(pStruct->pSignalSemaphoreValues));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
        {   // VkSemaphoreWaitInfo
            VkSemaphoreWaitInfo const *pStruct = static_cast<VkSemaphoreWaitInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphore - pSemaphores / semaphoreCount
            free(const_cast<VkSemaphore *>(pStruct->pSemaphores));

            // uint64_t - pValues / semaphoreCount
            free(const_cast<uint64_t *>(pStruct->pValues));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:
        {   // VkSemaphoreSignalInfo
            VkSemaphoreSignalInfo const *pStruct = static_cast<VkSemaphoreSignalInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
        {   // VkPipelineVertexInputDivisorStateCreateInfoEXT
            VkPipelineVertexInputDivisorStateCreateInfoEXT const *pStruct = static_cast<VkPipelineVertexInputDivisorStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVertexInputBindingDivisorDescriptionEXT - pVertexBindingDivisors / vertexBindingDivisorCount
            free(const_cast<VkVertexInputBindingDivisorDescriptionEXT *>(pStruct->pVertexBindingDivisors));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
        {   // VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
            VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
        {   // VkPhysicalDevicePCIBusInfoPropertiesEXT
            VkPhysicalDevicePCIBusInfoPropertiesEXT const *pStruct = static_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {   // VkImportAndroidHardwareBufferInfoANDROID
            VkImportAndroidHardwareBufferInfoANDROID const *pStruct = static_cast<VkImportAndroidHardwareBufferInfoANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
        {   // VkAndroidHardwareBufferUsageANDROID
            VkAndroidHardwareBufferUsageANDROID const *pStruct = static_cast<VkAndroidHardwareBufferUsageANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
        {   // VkAndroidHardwareBufferPropertiesANDROID
            VkAndroidHardwareBufferPropertiesANDROID const *pStruct = static_cast<VkAndroidHardwareBufferPropertiesANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
        {   // VkMemoryGetAndroidHardwareBufferInfoANDROID
            VkMemoryGetAndroidHardwareBufferInfoANDROID const *pStruct = static_cast<VkMemoryGetAndroidHardwareBufferInfoANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
        {   // VkAndroidHardwareBufferFormatPropertiesANDROID
            VkAndroidHardwareBufferFormatPropertiesANDROID const *pStruct = static_cast<VkAndroidHardwareBufferFormatPropertiesANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
        {   // VkCommandBufferInheritanceConditionalRenderingInfoEXT
            VkCommandBufferInheritanceConditionalRenderingInfoEXT const *pStruct = static_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
        {   // VkExternalFormatANDROID
            VkExternalFormatANDROID const *pStruct = static_cast<VkExternalFormatANDROID const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
        {   // VkPhysicalDevice8BitStorageFeatures
            VkPhysicalDevice8BitStorageFeatures const *pStruct = static_cast<VkPhysicalDevice8BitStorageFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
        {   // VkPhysicalDeviceConditionalRenderingFeaturesEXT
            VkPhysicalDeviceConditionalRenderingFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
        {   // VkPhysicalDeviceVulkanMemoryModelFeatures
            VkPhysicalDeviceVulkanMemoryModelFeatures const *pStruct = static_cast<VkPhysicalDeviceVulkanMemoryModelFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
        {   // VkPhysicalDeviceShaderAtomicInt64Features
            VkPhysicalDeviceShaderAtomicInt64Features const *pStruct = static_cast<VkPhysicalDeviceShaderAtomicInt64Features const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
        {   // VkPhysicalDeviceShaderAtomicFloatFeaturesEXT
            VkPhysicalDeviceShaderAtomicFloatFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
        {   // VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
            VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT:
        {   // VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
            VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
        {   // VkQueueFamilyCheckpointPropertiesNV
            VkQueueFamilyCheckpointPropertiesNV const *pStruct = static_cast<VkQueueFamilyCheckpointPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
        {   // VkCheckpointDataNV
            VkCheckpointDataNV const *pStruct = static_cast<VkCheckpointDataNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pCheckpointMarker
            free(const_cast<void *>(pStruct->pCheckpointMarker));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
        {   // VkPhysicalDeviceDepthStencilResolveProperties
            VkPhysicalDeviceDepthStencilResolveProperties const *pStruct = static_cast<VkPhysicalDeviceDepthStencilResolveProperties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
        {   // VkSubpassDescriptionDepthStencilResolve
            VkSubpassDescriptionDepthStencilResolve const *pStruct = static_cast<VkSubpassDescriptionDepthStencilResolve const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentReference2 - pDepthStencilResolveAttachment
            vk_struct_cleanup(pStruct->pDepthStencilResolveAttachment);
            free(const_cast<VkAttachmentReference2 *>(pStruct->pDepthStencilResolveAttachment));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
        {   // VkImageViewASTCDecodeModeEXT
            VkImageViewASTCDecodeModeEXT const *pStruct = static_cast<VkImageViewASTCDecodeModeEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
        {   // VkPhysicalDeviceASTCDecodeFeaturesEXT
            VkPhysicalDeviceASTCDecodeFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
        {   // VkPhysicalDeviceTransformFeedbackFeaturesEXT
            VkPhysicalDeviceTransformFeedbackFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
        {   // VkPhysicalDeviceTransformFeedbackPropertiesEXT
            VkPhysicalDeviceTransformFeedbackPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationStateStreamCreateInfoEXT
            VkPipelineRasterizationStateStreamCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationStateStreamCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
        {   // VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
            VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
        {   // VkPipelineRepresentativeFragmentTestStateCreateInfoNV
            VkPipelineRepresentativeFragmentTestStateCreateInfoNV const *pStruct = static_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
        {   // VkPhysicalDeviceExclusiveScissorFeaturesNV
            VkPhysicalDeviceExclusiveScissorFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportExclusiveScissorStateCreateInfoNV
            VkPipelineViewportExclusiveScissorStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkRect2D - pExclusiveScissors / exclusiveScissorCount
            free(const_cast<VkRect2D *>(pStruct->pExclusiveScissors));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
        {   // VkPhysicalDeviceCornerSampledImageFeaturesNV
            VkPhysicalDeviceCornerSampledImageFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
        {   // VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
            VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
        {   // VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV
            VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
        {   // VkPhysicalDeviceShaderImageFootprintFeaturesNV
            VkPhysicalDeviceShaderImageFootprintFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
        {   // VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
            VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportShadingRateImageStateCreateInfoNV
            VkPipelineViewportShadingRateImageStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkShadingRatePaletteNV - pShadingRatePalettes / viewportCount
            free(const_cast<VkShadingRatePaletteNV *>(pStruct->pShadingRatePalettes));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
        {   // VkPhysicalDeviceShadingRateImageFeaturesNV
            VkPhysicalDeviceShadingRateImageFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceShadingRateImageFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
        {   // VkPhysicalDeviceShadingRateImagePropertiesNV
            VkPhysicalDeviceShadingRateImagePropertiesNV const *pStruct = static_cast<VkPhysicalDeviceShadingRateImagePropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
        {   // VkPhysicalDeviceInvocationMaskFeaturesHUAWEI
            VkPhysicalDeviceInvocationMaskFeaturesHUAWEI const *pStruct = static_cast<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
        {   // VkPipelineViewportCoarseSampleOrderStateCreateInfoNV
            VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const *pStruct = static_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkCoarseSampleOrderCustomNV - pCustomSampleOrders / customSampleOrderCount
            free(const_cast<VkCoarseSampleOrderCustomNV *>(pStruct->pCustomSampleOrders));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
        {   // VkPhysicalDeviceMeshShaderFeaturesNV
            VkPhysicalDeviceMeshShaderFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceMeshShaderFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
        {   // VkPhysicalDeviceMeshShaderPropertiesNV
            VkPhysicalDeviceMeshShaderPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceMeshShaderPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
        {   // VkRayTracingShaderGroupCreateInfoNV
            VkRayTracingShaderGroupCreateInfoNV const *pStruct = static_cast<VkRayTracingShaderGroupCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
        {   // VkRayTracingShaderGroupCreateInfoKHR
            VkRayTracingShaderGroupCreateInfoKHR const *pStruct = static_cast<VkRayTracingShaderGroupCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pShaderGroupCaptureReplayHandle
            free(const_cast<void *>(pStruct->pShaderGroupCaptureReplayHandle));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
        {   // VkRayTracingPipelineCreateInfoNV
            VkRayTracingPipelineCreateInfoNV const *pStruct = static_cast<VkRayTracingPipelineCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineShaderStageCreateInfo - pStages / stageCount
            for (uint32_t i = 0; i < pStruct->stageCount; ++i)
                vk_struct_cleanup(&pStruct->pStages[i]);
            free(const_cast<VkPipelineShaderStageCreateInfo *>(pStruct->pStages));

            // VkRayTracingShaderGroupCreateInfoNV - pGroups / groupCount
            for (uint32_t i = 0; i < pStruct->groupCount; ++i)
                vk_struct_cleanup(&pStruct->pGroups[i]);
            free(const_cast<VkRayTracingShaderGroupCreateInfoNV *>(pStruct->pGroups));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR:
        {   // VkRayTracingPipelineCreateInfoKHR
            VkRayTracingPipelineCreateInfoKHR const *pStruct = static_cast<VkRayTracingPipelineCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineShaderStageCreateInfo - pStages / stageCount
            for (uint32_t i = 0; i < pStruct->stageCount; ++i)
                vk_struct_cleanup(&pStruct->pStages[i]);
            free(const_cast<VkPipelineShaderStageCreateInfo *>(pStruct->pStages));

            // VkRayTracingShaderGroupCreateInfoKHR - pGroups / groupCount
            for (uint32_t i = 0; i < pStruct->groupCount; ++i)
                vk_struct_cleanup(&pStruct->pGroups[i]);
            free(const_cast<VkRayTracingShaderGroupCreateInfoKHR *>(pStruct->pGroups));

            // VkPipelineLibraryCreateInfoKHR - pLibraryInfo
            vk_struct_cleanup(pStruct->pLibraryInfo);
            free(const_cast<VkPipelineLibraryCreateInfoKHR *>(pStruct->pLibraryInfo));

            // VkRayTracingPipelineInterfaceCreateInfoKHR - pLibraryInterface
            vk_struct_cleanup(pStruct->pLibraryInterface);
            free(const_cast<VkRayTracingPipelineInterfaceCreateInfoKHR *>(pStruct->pLibraryInterface));

            // VkPipelineDynamicStateCreateInfo - pDynamicState
            vk_struct_cleanup(pStruct->pDynamicState);
            free(const_cast<VkPipelineDynamicStateCreateInfo *>(pStruct->pDynamicState));
        }

        break;

    case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
        {   // VkGeometryTrianglesNV
            VkGeometryTrianglesNV const *pStruct = static_cast<VkGeometryTrianglesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
        {   // VkGeometryAABBNV
            VkGeometryAABBNV const *pStruct = static_cast<VkGeometryAABBNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_GEOMETRY_NV:
        {   // VkGeometryNV
            VkGeometryNV const *pStruct = static_cast<VkGeometryNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
        {   // VkAccelerationStructureInfoNV
            VkAccelerationStructureInfoNV const *pStruct = static_cast<VkAccelerationStructureInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkGeometryNV - pGeometries / geometryCount
            for (uint32_t i = 0; i < pStruct->geometryCount; ++i)
                vk_struct_cleanup(&pStruct->pGeometries[i]);
            free(const_cast<VkGeometryNV *>(pStruct->pGeometries));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
        {   // VkAccelerationStructureCreateInfoNV
            VkAccelerationStructureCreateInfoNV const *pStruct = static_cast<VkAccelerationStructureCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
        {   // VkBindAccelerationStructureMemoryInfoNV
            VkBindAccelerationStructureMemoryInfoNV const *pStruct = static_cast<VkBindAccelerationStructureMemoryInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pDeviceIndices / deviceIndexCount
            free(const_cast<uint32_t *>(pStruct->pDeviceIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
        {   // VkWriteDescriptorSetAccelerationStructureKHR
            VkWriteDescriptorSetAccelerationStructureKHR const *pStruct = static_cast<VkWriteDescriptorSetAccelerationStructureKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAccelerationStructureKHR - pAccelerationStructures / accelerationStructureCount
            free(const_cast<VkAccelerationStructureKHR *>(pStruct->pAccelerationStructures));
        }

        break;

    case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
        {   // VkWriteDescriptorSetAccelerationStructureNV
            VkWriteDescriptorSetAccelerationStructureNV const *pStruct = static_cast<VkWriteDescriptorSetAccelerationStructureNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAccelerationStructureNV - pAccelerationStructures / accelerationStructureCount
            free(const_cast<VkAccelerationStructureNV *>(pStruct->pAccelerationStructures));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
        {   // VkAccelerationStructureMemoryRequirementsInfoNV
            VkAccelerationStructureMemoryRequirementsInfoNV const *pStruct = static_cast<VkAccelerationStructureMemoryRequirementsInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
        {   // VkPhysicalDeviceAccelerationStructureFeaturesKHR
            VkPhysicalDeviceAccelerationStructureFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
        {   // VkPhysicalDeviceRayTracingPipelineFeaturesKHR
            VkPhysicalDeviceRayTracingPipelineFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
        {   // VkPhysicalDeviceRayQueryFeaturesKHR
            VkPhysicalDeviceRayQueryFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceRayQueryFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
        {   // VkPhysicalDeviceAccelerationStructurePropertiesKHR
            VkPhysicalDeviceAccelerationStructurePropertiesKHR const *pStruct = static_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
        {   // VkPhysicalDeviceRayTracingPipelinePropertiesKHR
            VkPhysicalDeviceRayTracingPipelinePropertiesKHR const *pStruct = static_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
        {   // VkPhysicalDeviceRayTracingPropertiesNV
            VkPhysicalDeviceRayTracingPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceRayTracingPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
        {   // VkDrmFormatModifierPropertiesListEXT
            VkDrmFormatModifierPropertiesListEXT const *pStruct = static_cast<VkDrmFormatModifierPropertiesListEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkDrmFormatModifierPropertiesEXT - pDrmFormatModifierProperties / drmFormatModifierCount
            free(const_cast<VkDrmFormatModifierPropertiesEXT *>(pStruct->pDrmFormatModifierProperties));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
        {   // VkPhysicalDeviceImageDrmFormatModifierInfoEXT
            VkPhysicalDeviceImageDrmFormatModifierInfoEXT const *pStruct = static_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pQueueFamilyIndices / queueFamilyIndexCount
            free(const_cast<uint32_t *>(pStruct->pQueueFamilyIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
        {   // VkImageDrmFormatModifierListCreateInfoEXT
            VkImageDrmFormatModifierListCreateInfoEXT const *pStruct = static_cast<VkImageDrmFormatModifierListCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint64_t - pDrmFormatModifiers / drmFormatModifierCount
            free(const_cast<uint64_t *>(pStruct->pDrmFormatModifiers));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
        {   // VkImageDrmFormatModifierExplicitCreateInfoEXT
            VkImageDrmFormatModifierExplicitCreateInfoEXT const *pStruct = static_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSubresourceLayout - pPlaneLayouts / drmFormatModifierPlaneCount
            free(const_cast<VkSubresourceLayout *>(pStruct->pPlaneLayouts));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
        {   // VkImageDrmFormatModifierPropertiesEXT
            VkImageDrmFormatModifierPropertiesEXT const *pStruct = static_cast<VkImageDrmFormatModifierPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
        {   // VkImageStencilUsageCreateInfo
            VkImageStencilUsageCreateInfo const *pStruct = static_cast<VkImageStencilUsageCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
        {   // VkDeviceMemoryOverallocationCreateInfoAMD
            VkDeviceMemoryOverallocationCreateInfoAMD const *pStruct = static_cast<VkDeviceMemoryOverallocationCreateInfoAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
        {   // VkPhysicalDeviceFragmentDensityMapFeaturesEXT
            VkPhysicalDeviceFragmentDensityMapFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
        {   // VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
            VkPhysicalDeviceFragmentDensityMap2FeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
        {   // VkPhysicalDeviceFragmentDensityMapPropertiesEXT
            VkPhysicalDeviceFragmentDensityMapPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
        {   // VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
            VkPhysicalDeviceFragmentDensityMap2PropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
        {   // VkRenderPassFragmentDensityMapCreateInfoEXT
            VkRenderPassFragmentDensityMapCreateInfoEXT const *pStruct = static_cast<VkRenderPassFragmentDensityMapCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
        {   // VkPhysicalDeviceScalarBlockLayoutFeatures
            VkPhysicalDeviceScalarBlockLayoutFeatures const *pStruct = static_cast<VkPhysicalDeviceScalarBlockLayoutFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
        {   // VkSurfaceProtectedCapabilitiesKHR
            VkSurfaceProtectedCapabilitiesKHR const *pStruct = static_cast<VkSurfaceProtectedCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
        {   // VkPhysicalDeviceUniformBufferStandardLayoutFeatures
            VkPhysicalDeviceUniformBufferStandardLayoutFeatures const *pStruct = static_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
        {   // VkPhysicalDeviceDepthClipEnableFeaturesEXT
            VkPhysicalDeviceDepthClipEnableFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationDepthClipStateCreateInfoEXT
            VkPipelineRasterizationDepthClipStateCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
        {   // VkPhysicalDeviceMemoryBudgetPropertiesEXT
            VkPhysicalDeviceMemoryBudgetPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
        {   // VkPhysicalDeviceMemoryPriorityFeaturesEXT
            VkPhysicalDeviceMemoryPriorityFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
        {   // VkMemoryPriorityAllocateInfoEXT
            VkMemoryPriorityAllocateInfoEXT const *pStruct = static_cast<VkMemoryPriorityAllocateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
        {   // VkPhysicalDeviceBufferDeviceAddressFeatures
            VkPhysicalDeviceBufferDeviceAddressFeatures const *pStruct = static_cast<VkPhysicalDeviceBufferDeviceAddressFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
        {   // VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
            VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:
        {   // VkBufferDeviceAddressInfo
            VkBufferDeviceAddressInfo const *pStruct = static_cast<VkBufferDeviceAddressInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
        {   // VkBufferOpaqueCaptureAddressCreateInfo
            VkBufferOpaqueCaptureAddressCreateInfo const *pStruct = static_cast<VkBufferOpaqueCaptureAddressCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
        {   // VkBufferDeviceAddressCreateInfoEXT
            VkBufferDeviceAddressCreateInfoEXT const *pStruct = static_cast<VkBufferDeviceAddressCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
        {   // VkPhysicalDeviceImageViewImageFormatInfoEXT
            VkPhysicalDeviceImageViewImageFormatInfoEXT const *pStruct = static_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
        {   // VkFilterCubicImageViewImageFormatPropertiesEXT
            VkFilterCubicImageViewImageFormatPropertiesEXT const *pStruct = static_cast<VkFilterCubicImageViewImageFormatPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
        {   // VkPhysicalDeviceImagelessFramebufferFeatures
            VkPhysicalDeviceImagelessFramebufferFeatures const *pStruct = static_cast<VkPhysicalDeviceImagelessFramebufferFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
        {   // VkFramebufferAttachmentsCreateInfo
            VkFramebufferAttachmentsCreateInfo const *pStruct = static_cast<VkFramebufferAttachmentsCreateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkFramebufferAttachmentImageInfo - pAttachmentImageInfos / attachmentImageInfoCount
            for (uint32_t i = 0; i < pStruct->attachmentImageInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pAttachmentImageInfos[i]);
            free(const_cast<VkFramebufferAttachmentImageInfo *>(pStruct->pAttachmentImageInfos));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
        {   // VkFramebufferAttachmentImageInfo
            VkFramebufferAttachmentImageInfo const *pStruct = static_cast<VkFramebufferAttachmentImageInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkFormat - pViewFormats / viewFormatCount
            free(const_cast<VkFormat *>(pStruct->pViewFormats));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
        {   // VkRenderPassAttachmentBeginInfo
            VkRenderPassAttachmentBeginInfo const *pStruct = static_cast<VkRenderPassAttachmentBeginInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageView - pAttachments / attachmentCount
            free(const_cast<VkImageView *>(pStruct->pAttachments));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
        {   // VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
            VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
        {   // VkPhysicalDeviceCooperativeMatrixFeaturesNV
            VkPhysicalDeviceCooperativeMatrixFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {   // VkPhysicalDeviceCooperativeMatrixPropertiesNV
            VkPhysicalDeviceCooperativeMatrixPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
        {   // VkCooperativeMatrixPropertiesNV
            VkCooperativeMatrixPropertiesNV const *pStruct = static_cast<VkCooperativeMatrixPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
        {   // VkPhysicalDeviceYcbcrImageArraysFeaturesEXT
            VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
        {   // VkImageViewHandleInfoNVX
            VkImageViewHandleInfoNVX const *pStruct = static_cast<VkImageViewHandleInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX:
        {   // VkImageViewAddressPropertiesNVX
            VkImageViewAddressPropertiesNVX const *pStruct = static_cast<VkImageViewAddressPropertiesNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_USE_PLATFORM_GGP
    case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
        {   // VkPresentFrameTokenGGP
            VkPresentFrameTokenGGP const *pStruct = static_cast<VkPresentFrameTokenGGP const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_GGP

    case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
        {   // VkPipelineCreationFeedbackCreateInfoEXT
            VkPipelineCreationFeedbackCreateInfoEXT const *pStruct = static_cast<VkPipelineCreationFeedbackCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipelineCreationFeedbackEXT - pPipelineCreationFeedback
            free(const_cast<VkPipelineCreationFeedbackEXT *>(pStruct->pPipelineCreationFeedback));

            // VkPipelineCreationFeedbackEXT - pPipelineStageCreationFeedbacks / pipelineStageCreationFeedbackCount
            free(const_cast<VkPipelineCreationFeedbackEXT *>(pStruct->pPipelineStageCreationFeedbacks));
        }

        break;

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
        {   // VkSurfaceFullScreenExclusiveInfoEXT
            VkSurfaceFullScreenExclusiveInfoEXT const *pStruct = static_cast<VkSurfaceFullScreenExclusiveInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
        {   // VkSurfaceFullScreenExclusiveWin32InfoEXT
            VkSurfaceFullScreenExclusiveWin32InfoEXT const *pStruct = static_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
    case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
        {   // VkSurfaceCapabilitiesFullScreenExclusiveEXT
            VkSurfaceCapabilitiesFullScreenExclusiveEXT const *pStruct = static_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_USE_PLATFORM_WIN32_KHR

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
        {   // VkPhysicalDevicePerformanceQueryFeaturesKHR
            VkPhysicalDevicePerformanceQueryFeaturesKHR const *pStruct = static_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
        {   // VkPhysicalDevicePerformanceQueryPropertiesKHR
            VkPhysicalDevicePerformanceQueryPropertiesKHR const *pStruct = static_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR:
        {   // VkPerformanceCounterKHR
            VkPerformanceCounterKHR const *pStruct = static_cast<VkPerformanceCounterKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR:
        {   // VkPerformanceCounterDescriptionKHR
            VkPerformanceCounterDescriptionKHR const *pStruct = static_cast<VkPerformanceCounterDescriptionKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
        {   // VkQueryPoolPerformanceCreateInfoKHR
            VkQueryPoolPerformanceCreateInfoKHR const *pStruct = static_cast<VkQueryPoolPerformanceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint32_t - pCounterIndices / counterIndexCount
            free(const_cast<uint32_t *>(pStruct->pCounterIndices));
        }

        break;

    case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR:
        {   // VkAcquireProfilingLockInfoKHR
            VkAcquireProfilingLockInfoKHR const *pStruct = static_cast<VkAcquireProfilingLockInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
        {   // VkPerformanceQuerySubmitInfoKHR
            VkPerformanceQuerySubmitInfoKHR const *pStruct = static_cast<VkPerformanceQuerySubmitInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
        {   // VkHeadlessSurfaceCreateInfoEXT
            VkHeadlessSurfaceCreateInfoEXT const *pStruct = static_cast<VkHeadlessSurfaceCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
        {   // VkPhysicalDeviceCoverageReductionModeFeaturesNV
            VkPhysicalDeviceCoverageReductionModeFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
        {   // VkPipelineCoverageReductionStateCreateInfoNV
            VkPipelineCoverageReductionStateCreateInfoNV const *pStruct = static_cast<VkPipelineCoverageReductionStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
        {   // VkFramebufferMixedSamplesCombinationNV
            VkFramebufferMixedSamplesCombinationNV const *pStruct = static_cast<VkFramebufferMixedSamplesCombinationNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
        {   // VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
            VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const *pStruct = static_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
        {   // VkInitializePerformanceApiInfoINTEL
            VkInitializePerformanceApiInfoINTEL const *pStruct = static_cast<VkInitializePerformanceApiInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pUserData
            free(const_cast<void *>(pStruct->pUserData));
        }

        break;

    case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
        {   // VkQueryPoolPerformanceQueryCreateInfoINTEL
            VkQueryPoolPerformanceQueryCreateInfoINTEL const *pStruct = static_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
        {   // VkPerformanceMarkerInfoINTEL
            VkPerformanceMarkerInfoINTEL const *pStruct = static_cast<VkPerformanceMarkerInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
        {   // VkPerformanceStreamMarkerInfoINTEL
            VkPerformanceStreamMarkerInfoINTEL const *pStruct = static_cast<VkPerformanceStreamMarkerInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
        {   // VkPerformanceOverrideInfoINTEL
            VkPerformanceOverrideInfoINTEL const *pStruct = static_cast<VkPerformanceOverrideInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
        {   // VkPerformanceConfigurationAcquireInfoINTEL
            VkPerformanceConfigurationAcquireInfoINTEL const *pStruct = static_cast<VkPerformanceConfigurationAcquireInfoINTEL const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
        {   // VkPhysicalDeviceShaderClockFeaturesKHR
            VkPhysicalDeviceShaderClockFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceShaderClockFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
        {   // VkPhysicalDeviceIndexTypeUint8FeaturesEXT
            VkPhysicalDeviceIndexTypeUint8FeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
        {   // VkPhysicalDeviceShaderSMBuiltinsPropertiesNV
            VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
        {   // VkPhysicalDeviceShaderSMBuiltinsFeaturesNV
            VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
        {   // VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
            VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
        {   // VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
            VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures const *pStruct = static_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
        {   // VkAttachmentReferenceStencilLayout
            VkAttachmentReferenceStencilLayout const *pStruct = static_cast<VkAttachmentReferenceStencilLayout const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
        {   // VkAttachmentDescriptionStencilLayout
            VkAttachmentDescriptionStencilLayout const *pStruct = static_cast<VkAttachmentDescriptionStencilLayout const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
        {   // VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
            VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR const *pStruct = static_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
        {   // VkPipelineInfoKHR
            VkPipelineInfoKHR const *pStruct = static_cast<VkPipelineInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
        {   // VkPipelineExecutablePropertiesKHR
            VkPipelineExecutablePropertiesKHR const *pStruct = static_cast<VkPipelineExecutablePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
        {   // VkPipelineExecutableInfoKHR
            VkPipelineExecutableInfoKHR const *pStruct = static_cast<VkPipelineExecutableInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
        {   // VkPipelineExecutableStatisticKHR
            VkPipelineExecutableStatisticKHR const *pStruct = static_cast<VkPipelineExecutableStatisticKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
        {   // VkPipelineExecutableInternalRepresentationKHR
            VkPipelineExecutableInternalRepresentationKHR const *pStruct = static_cast<VkPipelineExecutableInternalRepresentationKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pData / dataSize
            free(const_cast<void *>(pStruct->pData));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
        {   // VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
            VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
        {   // VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
            VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT:
        {   // VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
            VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
        {   // VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
            VkPhysicalDeviceSubgroupSizeControlFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
        {   // VkPhysicalDeviceSubgroupSizeControlPropertiesEXT
            VkPhysicalDeviceSubgroupSizeControlPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
        {   // VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT
            VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const *pStruct = static_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
        {   // VkSubpassShadingPipelineCreateInfoHUAWEI
            VkSubpassShadingPipelineCreateInfoHUAWEI const *pStruct = static_cast<VkSubpassShadingPipelineCreateInfoHUAWEI const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
        {   // VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
            VkPhysicalDeviceSubpassShadingPropertiesHUAWEI const *pStruct = static_cast<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
        {   // VkMemoryOpaqueCaptureAddressAllocateInfo
            VkMemoryOpaqueCaptureAddressAllocateInfo const *pStruct = static_cast<VkMemoryOpaqueCaptureAddressAllocateInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
        {   // VkDeviceMemoryOpaqueCaptureAddressInfo
            VkDeviceMemoryOpaqueCaptureAddressInfo const *pStruct = static_cast<VkDeviceMemoryOpaqueCaptureAddressInfo const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
        {   // VkPhysicalDeviceLineRasterizationFeaturesEXT
            VkPhysicalDeviceLineRasterizationFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
        {   // VkPhysicalDeviceLineRasterizationPropertiesEXT
            VkPhysicalDeviceLineRasterizationPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationLineStateCreateInfoEXT
            VkPipelineRasterizationLineStateCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationLineStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
        {   // VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT
            VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT const *pStruct = static_cast<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
        {   // VkPhysicalDeviceVulkan11Features
            VkPhysicalDeviceVulkan11Features const *pStruct = static_cast<VkPhysicalDeviceVulkan11Features const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
        {   // VkPhysicalDeviceVulkan11Properties
            VkPhysicalDeviceVulkan11Properties const *pStruct = static_cast<VkPhysicalDeviceVulkan11Properties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
        {   // VkPhysicalDeviceVulkan12Features
            VkPhysicalDeviceVulkan12Features const *pStruct = static_cast<VkPhysicalDeviceVulkan12Features const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
        {   // VkPhysicalDeviceVulkan12Properties
            VkPhysicalDeviceVulkan12Properties const *pStruct = static_cast<VkPhysicalDeviceVulkan12Properties const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
        {   // VkPipelineCompilerControlCreateInfoAMD
            VkPipelineCompilerControlCreateInfoAMD const *pStruct = static_cast<VkPipelineCompilerControlCreateInfoAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
        {   // VkPhysicalDeviceCoherentMemoryFeaturesAMD
            VkPhysicalDeviceCoherentMemoryFeaturesAMD const *pStruct = static_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT:
        {   // VkPhysicalDeviceToolPropertiesEXT
            VkPhysicalDeviceToolPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceToolPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
        {   // VkSamplerCustomBorderColorCreateInfoEXT
            VkSamplerCustomBorderColorCreateInfoEXT const *pStruct = static_cast<VkSamplerCustomBorderColorCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
        {   // VkPhysicalDeviceCustomBorderColorPropertiesEXT
            VkPhysicalDeviceCustomBorderColorPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
        {   // VkPhysicalDeviceCustomBorderColorFeaturesEXT
            VkPhysicalDeviceCustomBorderColorFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
        {   // VkAccelerationStructureGeometryTrianglesDataKHR
            VkAccelerationStructureGeometryTrianglesDataKHR const *pStruct = static_cast<VkAccelerationStructureGeometryTrianglesDataKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
        {   // VkAccelerationStructureGeometryAabbsDataKHR
            VkAccelerationStructureGeometryAabbsDataKHR const *pStruct = static_cast<VkAccelerationStructureGeometryAabbsDataKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
        {   // VkAccelerationStructureGeometryInstancesDataKHR
            VkAccelerationStructureGeometryInstancesDataKHR const *pStruct = static_cast<VkAccelerationStructureGeometryInstancesDataKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR:
        {   // VkAccelerationStructureGeometryKHR
            VkAccelerationStructureGeometryKHR const *pStruct = static_cast<VkAccelerationStructureGeometryKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
        {   // VkAccelerationStructureBuildGeometryInfoKHR
            VkAccelerationStructureBuildGeometryInfoKHR const *pStruct = static_cast<VkAccelerationStructureBuildGeometryInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAccelerationStructureGeometryKHR - pGeometries / geometryCount
            for (uint32_t i = 0; i < pStruct->geometryCount; ++i)
                vk_struct_cleanup(&pStruct->pGeometries[i]);
            free(const_cast<VkAccelerationStructureGeometryKHR *>(pStruct->pGeometries));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
        {   // VkAccelerationStructureCreateInfoKHR
            VkAccelerationStructureCreateInfoKHR const *pStruct = static_cast<VkAccelerationStructureCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
        {   // VkAccelerationStructureDeviceAddressInfoKHR
            VkAccelerationStructureDeviceAddressInfoKHR const *pStruct = static_cast<VkAccelerationStructureDeviceAddressInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
        {   // VkAccelerationStructureVersionInfoKHR
            VkAccelerationStructureVersionInfoKHR const *pStruct = static_cast<VkAccelerationStructureVersionInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // uint8_t - pVersionData / 2*ename:VK_UUID_SIZE
            free(const_cast<uint8_t *>(pStruct->pVersionData));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR:
        {   // VkCopyAccelerationStructureInfoKHR
            VkCopyAccelerationStructureInfoKHR const *pStruct = static_cast<VkCopyAccelerationStructureInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
        {   // VkCopyAccelerationStructureToMemoryInfoKHR
            VkCopyAccelerationStructureToMemoryInfoKHR const *pStruct = static_cast<VkCopyAccelerationStructureToMemoryInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
        {   // VkCopyMemoryToAccelerationStructureInfoKHR
            VkCopyMemoryToAccelerationStructureInfoKHR const *pStruct = static_cast<VkCopyMemoryToAccelerationStructureInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
        {   // VkRayTracingPipelineInterfaceCreateInfoKHR
            VkRayTracingPipelineInterfaceCreateInfoKHR const *pStruct = static_cast<VkRayTracingPipelineInterfaceCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
        {   // VkPipelineLibraryCreateInfoKHR
            VkPipelineLibraryCreateInfoKHR const *pStruct = static_cast<VkPipelineLibraryCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkPipeline - pLibraries / libraryCount
            free(const_cast<VkPipeline *>(pStruct->pLibraries));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
        {   // VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
            VkPhysicalDeviceExtendedDynamicStateFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
        {   // VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
            VkPhysicalDeviceExtendedDynamicState2FeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
        {   // VkRenderPassTransformBeginInfoQCOM
            VkRenderPassTransformBeginInfoQCOM const *pStruct = static_cast<VkRenderPassTransformBeginInfoQCOM const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
        {   // VkCopyCommandTransformInfoQCOM
            VkCopyCommandTransformInfoQCOM const *pStruct = static_cast<VkCopyCommandTransformInfoQCOM const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
        {   // VkCommandBufferInheritanceRenderPassTransformInfoQCOM
            VkCommandBufferInheritanceRenderPassTransformInfoQCOM const *pStruct = static_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
        {   // VkPhysicalDeviceDiagnosticsConfigFeaturesNV
            VkPhysicalDeviceDiagnosticsConfigFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
        {   // VkDeviceDiagnosticsConfigCreateInfoNV
            VkDeviceDiagnosticsConfigCreateInfoNV const *pStruct = static_cast<VkDeviceDiagnosticsConfigCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR:
        {   // VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
            VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
        {   // VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
            VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
        {   // VkPhysicalDeviceRobustness2FeaturesEXT
            VkPhysicalDeviceRobustness2FeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceRobustness2FeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
        {   // VkPhysicalDeviceRobustness2PropertiesEXT
            VkPhysicalDeviceRobustness2PropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceRobustness2PropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
        {   // VkPhysicalDeviceImageRobustnessFeaturesEXT
            VkPhysicalDeviceImageRobustnessFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceImageRobustnessFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
        {   // VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
            VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
        {   // VkPhysicalDevicePortabilitySubsetFeaturesKHR
            VkPhysicalDevicePortabilitySubsetFeaturesKHR const *pStruct = static_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
        {   // VkPhysicalDevicePortabilitySubsetPropertiesKHR
            VkPhysicalDevicePortabilitySubsetPropertiesKHR const *pStruct = static_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
        {   // VkPhysicalDevice4444FormatsFeaturesEXT
            VkPhysicalDevice4444FormatsFeaturesEXT const *pStruct = static_cast<VkPhysicalDevice4444FormatsFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
        {   // VkPhysicalDeviceSubpassShadingFeaturesHUAWEI
            VkPhysicalDeviceSubpassShadingFeaturesHUAWEI const *pStruct = static_cast<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR:
        {   // VkBufferCopy2KHR
            VkBufferCopy2KHR const *pStruct = static_cast<VkBufferCopy2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR:
        {   // VkImageCopy2KHR
            VkImageCopy2KHR const *pStruct = static_cast<VkImageCopy2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR:
        {   // VkImageBlit2KHR
            VkImageBlit2KHR const *pStruct = static_cast<VkImageBlit2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR:
        {   // VkBufferImageCopy2KHR
            VkBufferImageCopy2KHR const *pStruct = static_cast<VkBufferImageCopy2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR:
        {   // VkImageResolve2KHR
            VkImageResolve2KHR const *pStruct = static_cast<VkImageResolve2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR:
        {   // VkCopyBufferInfo2KHR
            VkCopyBufferInfo2KHR const *pStruct = static_cast<VkCopyBufferInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkBufferCopy2KHR - pRegions / regionCount
            for (uint32_t i = 0; i < pStruct->regionCount; ++i)
                vk_struct_cleanup(&pStruct->pRegions[i]);
            free(const_cast<VkBufferCopy2KHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR:
        {   // VkCopyImageInfo2KHR
            VkCopyImageInfo2KHR const *pStruct = static_cast<VkCopyImageInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageCopy2KHR - pRegions / regionCount
            for (uint32_t i = 0; i < pStruct->regionCount; ++i)
                vk_struct_cleanup(&pStruct->pRegions[i]);
            free(const_cast<VkImageCopy2KHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR:
        {   // VkBlitImageInfo2KHR
            VkBlitImageInfo2KHR const *pStruct = static_cast<VkBlitImageInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageBlit2KHR - pRegions / regionCount
            for (uint32_t i = 0; i < pStruct->regionCount; ++i)
                vk_struct_cleanup(&pStruct->pRegions[i]);
            free(const_cast<VkImageBlit2KHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR:
        {   // VkCopyBufferToImageInfo2KHR
            VkCopyBufferToImageInfo2KHR const *pStruct = static_cast<VkCopyBufferToImageInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkBufferImageCopy2KHR - pRegions / regionCount
            for (uint32_t i = 0; i < pStruct->regionCount; ++i)
                vk_struct_cleanup(&pStruct->pRegions[i]);
            free(const_cast<VkBufferImageCopy2KHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR:
        {   // VkCopyImageToBufferInfo2KHR
            VkCopyImageToBufferInfo2KHR const *pStruct = static_cast<VkCopyImageToBufferInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkBufferImageCopy2KHR - pRegions / regionCount
            for (uint32_t i = 0; i < pStruct->regionCount; ++i)
                vk_struct_cleanup(&pStruct->pRegions[i]);
            free(const_cast<VkBufferImageCopy2KHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR:
        {   // VkResolveImageInfo2KHR
            VkResolveImageInfo2KHR const *pStruct = static_cast<VkResolveImageInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkImageResolve2KHR - pRegions / regionCount
            for (uint32_t i = 0; i < pStruct->regionCount; ++i)
                vk_struct_cleanup(&pStruct->pRegions[i]);
            free(const_cast<VkImageResolve2KHR *>(pStruct->pRegions));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
        {   // VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
            VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
        {   // VkFragmentShadingRateAttachmentInfoKHR
            VkFragmentShadingRateAttachmentInfoKHR const *pStruct = static_cast<VkFragmentShadingRateAttachmentInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkAttachmentReference2 - pFragmentShadingRateAttachment
            vk_struct_cleanup(pStruct->pFragmentShadingRateAttachment);
            free(const_cast<VkAttachmentReference2 *>(pStruct->pFragmentShadingRateAttachment));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
        {   // VkPipelineFragmentShadingRateStateCreateInfoKHR
            VkPipelineFragmentShadingRateStateCreateInfoKHR const *pStruct = static_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
        {   // VkPhysicalDeviceFragmentShadingRateFeaturesKHR
            VkPhysicalDeviceFragmentShadingRateFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
        {   // VkPhysicalDeviceFragmentShadingRatePropertiesKHR
            VkPhysicalDeviceFragmentShadingRatePropertiesKHR const *pStruct = static_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
        {   // VkPhysicalDeviceFragmentShadingRateKHR
            VkPhysicalDeviceFragmentShadingRateKHR const *pStruct = static_cast<VkPhysicalDeviceFragmentShadingRateKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
        {   // VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
            VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
        {   // VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
            VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
        {   // VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
            VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV const *pStruct = static_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
        {   // VkPipelineFragmentShadingRateEnumStateCreateInfoNV
            VkPipelineFragmentShadingRateEnumStateCreateInfoNV const *pStruct = static_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
        {   // VkAccelerationStructureBuildSizesInfoKHR
            VkAccelerationStructureBuildSizesInfoKHR const *pStruct = static_cast<VkAccelerationStructureBuildSizesInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE:
        {   // VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
            VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE const *pStruct = static_cast<VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE:
        {   // VkMutableDescriptorTypeCreateInfoVALVE
            VkMutableDescriptorTypeCreateInfoVALVE const *pStruct = static_cast<VkMutableDescriptorTypeCreateInfoVALVE const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkMutableDescriptorTypeListVALVE - pMutableDescriptorTypeLists / mutableDescriptorTypeListCount
            free(const_cast<VkMutableDescriptorTypeListVALVE *>(pStruct->pMutableDescriptorTypeLists));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
        {   // VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
            VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
        {   // VkPhysicalDeviceExternalMemoryRDMAFeaturesNV
            VkPhysicalDeviceExternalMemoryRDMAFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
        {   // VkVertexInputBindingDescription2EXT
            VkVertexInputBindingDescription2EXT const *pStruct = static_cast<VkVertexInputBindingDescription2EXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
        {   // VkVertexInputAttributeDescription2EXT
            VkVertexInputAttributeDescription2EXT const *pStruct = static_cast<VkVertexInputAttributeDescription2EXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
        {   // VkPhysicalDeviceColorWriteEnableFeaturesEXT
            VkPhysicalDeviceColorWriteEnableFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceColorWriteEnableFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
        {   // VkPipelineColorWriteCreateInfoEXT
            VkPipelineColorWriteCreateInfoEXT const *pStruct = static_cast<VkPipelineColorWriteCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkBool32 - pColorWriteEnables / attachmentCount
            free(const_cast<VkBool32 *>(pStruct->pColorWriteEnables));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR:
        {   // VkMemoryBarrier2KHR
            VkMemoryBarrier2KHR const *pStruct = static_cast<VkMemoryBarrier2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR:
        {   // VkImageMemoryBarrier2KHR
            VkImageMemoryBarrier2KHR const *pStruct = static_cast<VkImageMemoryBarrier2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR:
        {   // VkBufferMemoryBarrier2KHR
            VkBufferMemoryBarrier2KHR const *pStruct = static_cast<VkBufferMemoryBarrier2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR:
        {   // VkDependencyInfoKHR
            VkDependencyInfoKHR const *pStruct = static_cast<VkDependencyInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkMemoryBarrier2KHR - pMemoryBarriers / memoryBarrierCount
            for (uint32_t i = 0; i < pStruct->memoryBarrierCount; ++i)
                vk_struct_cleanup(&pStruct->pMemoryBarriers[i]);
            free(const_cast<VkMemoryBarrier2KHR *>(pStruct->pMemoryBarriers));

            // VkBufferMemoryBarrier2KHR - pBufferMemoryBarriers / bufferMemoryBarrierCount
            for (uint32_t i = 0; i < pStruct->bufferMemoryBarrierCount; ++i)
                vk_struct_cleanup(&pStruct->pBufferMemoryBarriers[i]);
            free(const_cast<VkBufferMemoryBarrier2KHR *>(pStruct->pBufferMemoryBarriers));

            // VkImageMemoryBarrier2KHR - pImageMemoryBarriers / imageMemoryBarrierCount
            for (uint32_t i = 0; i < pStruct->imageMemoryBarrierCount; ++i)
                vk_struct_cleanup(&pStruct->pImageMemoryBarriers[i]);
            free(const_cast<VkImageMemoryBarrier2KHR *>(pStruct->pImageMemoryBarriers));
        }

        break;

    case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR:
        {   // VkSemaphoreSubmitInfoKHR
            VkSemaphoreSubmitInfoKHR const *pStruct = static_cast<VkSemaphoreSubmitInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR:
        {   // VkCommandBufferSubmitInfoKHR
            VkCommandBufferSubmitInfoKHR const *pStruct = static_cast<VkCommandBufferSubmitInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR:
        {   // VkSubmitInfo2KHR
            VkSubmitInfo2KHR const *pStruct = static_cast<VkSubmitInfo2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkSemaphoreSubmitInfoKHR - pWaitSemaphoreInfos / waitSemaphoreInfoCount
            for (uint32_t i = 0; i < pStruct->waitSemaphoreInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pWaitSemaphoreInfos[i]);
            free(const_cast<VkSemaphoreSubmitInfoKHR *>(pStruct->pWaitSemaphoreInfos));

            // VkCommandBufferSubmitInfoKHR - pCommandBufferInfos / commandBufferInfoCount
            for (uint32_t i = 0; i < pStruct->commandBufferInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pCommandBufferInfos[i]);
            free(const_cast<VkCommandBufferSubmitInfoKHR *>(pStruct->pCommandBufferInfos));

            // VkSemaphoreSubmitInfoKHR - pSignalSemaphoreInfos / signalSemaphoreInfoCount
            for (uint32_t i = 0; i < pStruct->signalSemaphoreInfoCount; ++i)
                vk_struct_cleanup(&pStruct->pSignalSemaphoreInfos[i]);
            free(const_cast<VkSemaphoreSubmitInfoKHR *>(pStruct->pSignalSemaphoreInfos));
        }

        break;

    case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
        {   // VkQueueFamilyCheckpointProperties2NV
            VkQueueFamilyCheckpointProperties2NV const *pStruct = static_cast<VkQueueFamilyCheckpointProperties2NV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV:
        {   // VkCheckpointData2NV
            VkCheckpointData2NV const *pStruct = static_cast<VkCheckpointData2NV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pCheckpointMarker
            free(const_cast<void *>(pStruct->pCheckpointMarker));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR:
        {   // VkPhysicalDeviceSynchronization2FeaturesKHR
            VkPhysicalDeviceSynchronization2FeaturesKHR const *pStruct = static_cast<VkPhysicalDeviceSynchronization2FeaturesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR:
        {   // VkVideoQueueFamilyProperties2KHR
            VkVideoQueueFamilyProperties2KHR const *pStruct = static_cast<VkVideoQueueFamilyProperties2KHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR:
        {   // VkVideoProfilesKHR
            VkVideoProfilesKHR const *pStruct = static_cast<VkVideoProfilesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoProfileKHR - pProfiles
            vk_struct_cleanup(pStruct->pProfiles);
            free(const_cast<VkVideoProfileKHR *>(pStruct->pProfiles));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR:
        {   // VkPhysicalDeviceVideoFormatInfoKHR
            VkPhysicalDeviceVideoFormatInfoKHR const *pStruct = static_cast<VkPhysicalDeviceVideoFormatInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoProfilesKHR - pVideoProfiles
            vk_struct_cleanup(pStruct->pVideoProfiles);
            free(const_cast<VkVideoProfilesKHR *>(pStruct->pVideoProfiles));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR:
        {   // VkVideoFormatPropertiesKHR
            VkVideoFormatPropertiesKHR const *pStruct = static_cast<VkVideoFormatPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR:
        {   // VkVideoProfileKHR
            VkVideoProfileKHR const *pStruct = static_cast<VkVideoProfileKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR:
        {   // VkVideoCapabilitiesKHR
            VkVideoCapabilitiesKHR const *pStruct = static_cast<VkVideoCapabilitiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR:
        {   // VkVideoGetMemoryPropertiesKHR
            VkVideoGetMemoryPropertiesKHR const *pStruct = static_cast<VkVideoGetMemoryPropertiesKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkMemoryRequirements2 - pMemoryRequirements
            vk_struct_cleanup(pStruct->pMemoryRequirements);
            free(const_cast<VkMemoryRequirements2 *>(pStruct->pMemoryRequirements));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR:
        {   // VkVideoBindMemoryKHR
            VkVideoBindMemoryKHR const *pStruct = static_cast<VkVideoBindMemoryKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR:
        {   // VkVideoPictureResourceKHR
            VkVideoPictureResourceKHR const *pStruct = static_cast<VkVideoPictureResourceKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR:
        {   // VkVideoReferenceSlotKHR
            VkVideoReferenceSlotKHR const *pStruct = static_cast<VkVideoReferenceSlotKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoPictureResourceKHR - pPictureResource
            vk_struct_cleanup(pStruct->pPictureResource);
            free(const_cast<VkVideoPictureResourceKHR *>(pStruct->pPictureResource));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR:
        {   // VkVideoDecodeInfoKHR
            VkVideoDecodeInfoKHR const *pStruct = static_cast<VkVideoDecodeInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoReferenceSlotKHR - pSetupReferenceSlot
            vk_struct_cleanup(pStruct->pSetupReferenceSlot);
            free(const_cast<VkVideoReferenceSlotKHR *>(pStruct->pSetupReferenceSlot));

            // VkVideoReferenceSlotKHR - pReferenceSlots / referenceSlotCount
            for (uint32_t i = 0; i < pStruct->referenceSlotCount; ++i)
                vk_struct_cleanup(&pStruct->pReferenceSlots[i]);
            free(const_cast<VkVideoReferenceSlotKHR *>(pStruct->pReferenceSlots));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT:
        {   // VkVideoDecodeH264ProfileEXT
            VkVideoDecodeH264ProfileEXT const *pStruct = static_cast<VkVideoDecodeH264ProfileEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT:
        {   // VkVideoDecodeH264CapabilitiesEXT
            VkVideoDecodeH264CapabilitiesEXT const *pStruct = static_cast<VkVideoDecodeH264CapabilitiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT:
        {   // VkVideoDecodeH264SessionCreateInfoEXT
            VkVideoDecodeH264SessionCreateInfoEXT const *pStruct = static_cast<VkVideoDecodeH264SessionCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkExtensionProperties - pStdExtensionVersion
            free(const_cast<VkExtensionProperties *>(pStruct->pStdExtensionVersion));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT:
        {   // VkVideoDecodeH264SessionParametersAddInfoEXT
            VkVideoDecodeH264SessionParametersAddInfoEXT const *pStruct = static_cast<VkVideoDecodeH264SessionParametersAddInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoH264SequenceParameterSet - pSpsStd / spsStdCount
            free(const_cast<StdVideoH264SequenceParameterSet *>(pStruct->pSpsStd));

            // StdVideoH264PictureParameterSet - pPpsStd / ppsStdCount
            free(const_cast<StdVideoH264PictureParameterSet *>(pStruct->pPpsStd));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {   // VkVideoDecodeH264SessionParametersCreateInfoEXT
            VkVideoDecodeH264SessionParametersCreateInfoEXT const *pStruct = static_cast<VkVideoDecodeH264SessionParametersCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoDecodeH264SessionParametersAddInfoEXT - pParametersAddInfo
            vk_struct_cleanup(pStruct->pParametersAddInfo);
            free(const_cast<VkVideoDecodeH264SessionParametersAddInfoEXT *>(pStruct->pParametersAddInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT:
        {   // VkVideoDecodeH264PictureInfoEXT
            VkVideoDecodeH264PictureInfoEXT const *pStruct = static_cast<VkVideoDecodeH264PictureInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoDecodeH264PictureInfo - pStdPictureInfo
            free(const_cast<StdVideoDecodeH264PictureInfo *>(pStruct->pStdPictureInfo));

            // uint32_t - pSlicesDataOffsets / slicesCount
            free(const_cast<uint32_t *>(pStruct->pSlicesDataOffsets));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT:
        {   // VkVideoDecodeH264DpbSlotInfoEXT
            VkVideoDecodeH264DpbSlotInfoEXT const *pStruct = static_cast<VkVideoDecodeH264DpbSlotInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoDecodeH264ReferenceInfo - pStdReferenceInfo
            free(const_cast<StdVideoDecodeH264ReferenceInfo *>(pStruct->pStdReferenceInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT:
        {   // VkVideoDecodeH264MvcEXT
            VkVideoDecodeH264MvcEXT const *pStruct = static_cast<VkVideoDecodeH264MvcEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoDecodeH264Mvc - pStdMvc
            free(const_cast<StdVideoDecodeH264Mvc *>(pStruct->pStdMvc));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT:
        {   // VkVideoDecodeH265ProfileEXT
            VkVideoDecodeH265ProfileEXT const *pStruct = static_cast<VkVideoDecodeH265ProfileEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT:
        {   // VkVideoDecodeH265CapabilitiesEXT
            VkVideoDecodeH265CapabilitiesEXT const *pStruct = static_cast<VkVideoDecodeH265CapabilitiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT:
        {   // VkVideoDecodeH265SessionCreateInfoEXT
            VkVideoDecodeH265SessionCreateInfoEXT const *pStruct = static_cast<VkVideoDecodeH265SessionCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkExtensionProperties - pStdExtensionVersion
            free(const_cast<VkExtensionProperties *>(pStruct->pStdExtensionVersion));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT:
        {   // VkVideoDecodeH265SessionParametersAddInfoEXT
            VkVideoDecodeH265SessionParametersAddInfoEXT const *pStruct = static_cast<VkVideoDecodeH265SessionParametersAddInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoH265SequenceParameterSet - pSpsStd / spsStdCount
            free(const_cast<StdVideoH265SequenceParameterSet *>(pStruct->pSpsStd));

            // StdVideoH265PictureParameterSet - pPpsStd / ppsStdCount
            free(const_cast<StdVideoH265PictureParameterSet *>(pStruct->pPpsStd));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {   // VkVideoDecodeH265SessionParametersCreateInfoEXT
            VkVideoDecodeH265SessionParametersCreateInfoEXT const *pStruct = static_cast<VkVideoDecodeH265SessionParametersCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoDecodeH265SessionParametersAddInfoEXT - pParametersAddInfo
            vk_struct_cleanup(pStruct->pParametersAddInfo);
            free(const_cast<VkVideoDecodeH265SessionParametersAddInfoEXT *>(pStruct->pParametersAddInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT:
        {   // VkVideoDecodeH265PictureInfoEXT
            VkVideoDecodeH265PictureInfoEXT const *pStruct = static_cast<VkVideoDecodeH265PictureInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoDecodeH265PictureInfo - pStdPictureInfo
            free(const_cast<StdVideoDecodeH265PictureInfo *>(pStruct->pStdPictureInfo));

            // uint32_t - pSlicesDataOffsets / slicesCount
            free(const_cast<uint32_t *>(pStruct->pSlicesDataOffsets));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT:
        {   // VkVideoDecodeH265DpbSlotInfoEXT
            VkVideoDecodeH265DpbSlotInfoEXT const *pStruct = static_cast<VkVideoDecodeH265DpbSlotInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoDecodeH265ReferenceInfo - pStdReferenceInfo
            free(const_cast<StdVideoDecodeH265ReferenceInfo *>(pStruct->pStdReferenceInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR:
        {   // VkVideoSessionCreateInfoKHR
            VkVideoSessionCreateInfoKHR const *pStruct = static_cast<VkVideoSessionCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoProfileKHR - pVideoProfile
            vk_struct_cleanup(pStruct->pVideoProfile);
            free(const_cast<VkVideoProfileKHR *>(pStruct->pVideoProfile));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:
        {   // VkVideoSessionParametersCreateInfoKHR
            VkVideoSessionParametersCreateInfoKHR const *pStruct = static_cast<VkVideoSessionParametersCreateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:
        {   // VkVideoSessionParametersUpdateInfoKHR
            VkVideoSessionParametersUpdateInfoKHR const *pStruct = static_cast<VkVideoSessionParametersUpdateInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR:
        {   // VkVideoBeginCodingInfoKHR
            VkVideoBeginCodingInfoKHR const *pStruct = static_cast<VkVideoBeginCodingInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoReferenceSlotKHR - pReferenceSlots / referenceSlotCount
            for (uint32_t i = 0; i < pStruct->referenceSlotCount; ++i)
                vk_struct_cleanup(&pStruct->pReferenceSlots[i]);
            free(const_cast<VkVideoReferenceSlotKHR *>(pStruct->pReferenceSlots));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR:
        {   // VkVideoEndCodingInfoKHR
            VkVideoEndCodingInfoKHR const *pStruct = static_cast<VkVideoEndCodingInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR:
        {   // VkVideoCodingControlInfoKHR
            VkVideoCodingControlInfoKHR const *pStruct = static_cast<VkVideoCodingControlInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR:
        {   // VkVideoEncodeInfoKHR
            VkVideoEncodeInfoKHR const *pStruct = static_cast<VkVideoEncodeInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoReferenceSlotKHR - pSetupReferenceSlot
            vk_struct_cleanup(pStruct->pSetupReferenceSlot);
            free(const_cast<VkVideoReferenceSlotKHR *>(pStruct->pSetupReferenceSlot));

            // VkVideoReferenceSlotKHR - pReferenceSlots / referenceSlotCount
            for (uint32_t i = 0; i < pStruct->referenceSlotCount; ++i)
                vk_struct_cleanup(&pStruct->pReferenceSlots[i]);
            free(const_cast<VkVideoReferenceSlotKHR *>(pStruct->pReferenceSlots));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
        {   // VkVideoEncodeRateControlInfoKHR
            VkVideoEncodeRateControlInfoKHR const *pStruct = static_cast<VkVideoEncodeRateControlInfoKHR const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT:
        {   // VkVideoEncodeH264CapabilitiesEXT
            VkVideoEncodeH264CapabilitiesEXT const *pStruct = static_cast<VkVideoEncodeH264CapabilitiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT:
        {   // VkVideoEncodeH264SessionCreateInfoEXT
            VkVideoEncodeH264SessionCreateInfoEXT const *pStruct = static_cast<VkVideoEncodeH264SessionCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkExtensionProperties - pStdExtensionVersion
            free(const_cast<VkExtensionProperties *>(pStruct->pStdExtensionVersion));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT:
        {   // VkVideoEncodeH264SessionParametersAddInfoEXT
            VkVideoEncodeH264SessionParametersAddInfoEXT const *pStruct = static_cast<VkVideoEncodeH264SessionParametersAddInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoH264SequenceParameterSet - pSpsStd / spsStdCount
            free(const_cast<StdVideoH264SequenceParameterSet *>(pStruct->pSpsStd));

            // StdVideoH264PictureParameterSet - pPpsStd / ppsStdCount
            free(const_cast<StdVideoH264PictureParameterSet *>(pStruct->pPpsStd));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT:
        {   // VkVideoEncodeH264SessionParametersCreateInfoEXT
            VkVideoEncodeH264SessionParametersCreateInfoEXT const *pStruct = static_cast<VkVideoEncodeH264SessionParametersCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoEncodeH264SessionParametersAddInfoEXT - pParametersAddInfo
            vk_struct_cleanup(pStruct->pParametersAddInfo);
            free(const_cast<VkVideoEncodeH264SessionParametersAddInfoEXT *>(pStruct->pParametersAddInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT:
        {   // VkVideoEncodeH264DpbSlotInfoEXT
            VkVideoEncodeH264DpbSlotInfoEXT const *pStruct = static_cast<VkVideoEncodeH264DpbSlotInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoEncodeH264PictureInfo - pStdPictureInfo
            free(const_cast<StdVideoEncodeH264PictureInfo *>(pStruct->pStdPictureInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT:
        {   // VkVideoEncodeH264VclFrameInfoEXT
            VkVideoEncodeH264VclFrameInfoEXT const *pStruct = static_cast<VkVideoEncodeH264VclFrameInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkVideoEncodeH264DpbSlotInfoEXT - pRefDefaultFinalList0Entries / refDefaultFinalList0EntryCount
            for (uint32_t i = 0; i < pStruct->refDefaultFinalList0EntryCount; ++i)
                vk_struct_cleanup(&pStruct->pRefDefaultFinalList0Entries[i]);
            free(const_cast<VkVideoEncodeH264DpbSlotInfoEXT *>(pStruct->pRefDefaultFinalList0Entries));

            // VkVideoEncodeH264DpbSlotInfoEXT - pRefDefaultFinalList1Entries / refDefaultFinalList1EntryCount
            for (uint32_t i = 0; i < pStruct->refDefaultFinalList1EntryCount; ++i)
                vk_struct_cleanup(&pStruct->pRefDefaultFinalList1Entries[i]);
            free(const_cast<VkVideoEncodeH264DpbSlotInfoEXT *>(pStruct->pRefDefaultFinalList1Entries));

            // VkVideoEncodeH264NaluSliceEXT - pNaluSliceEntries / naluSliceEntryCount
            for (uint32_t i = 0; i < pStruct->naluSliceEntryCount; ++i)
                vk_struct_cleanup(&pStruct->pNaluSliceEntries[i]);
            free(const_cast<VkVideoEncodeH264NaluSliceEXT *>(pStruct->pNaluSliceEntries));

            // VkVideoEncodeH264DpbSlotInfoEXT - pCurrentPictureInfo
            vk_struct_cleanup(pStruct->pCurrentPictureInfo);
            free(const_cast<VkVideoEncodeH264DpbSlotInfoEXT *>(pStruct->pCurrentPictureInfo));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT:
        {   // VkVideoEncodeH264EmitPictureParametersEXT
            VkVideoEncodeH264EmitPictureParametersEXT const *pStruct = static_cast<VkVideoEncodeH264EmitPictureParametersEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT:
        {   // VkVideoEncodeH264ProfileEXT
            VkVideoEncodeH264ProfileEXT const *pStruct = static_cast<VkVideoEncodeH264ProfileEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
    case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT:
        {   // VkVideoEncodeH264NaluSliceEXT
            VkVideoEncodeH264NaluSliceEXT const *pStruct = static_cast<VkVideoEncodeH264NaluSliceEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // StdVideoEncodeH264SliceHeader - pSliceHeaderStd
            free(const_cast<StdVideoEncodeH264SliceHeader *>(pStruct->pSliceHeaderStd));

            // VkVideoEncodeH264DpbSlotInfoEXT - pRefFinalList0Entries / refFinalList0EntryCount
            for (uint32_t i = 0; i < pStruct->refFinalList0EntryCount; ++i)
                vk_struct_cleanup(&pStruct->pRefFinalList0Entries[i]);
            free(const_cast<VkVideoEncodeH264DpbSlotInfoEXT *>(pStruct->pRefFinalList0Entries));

            // VkVideoEncodeH264DpbSlotInfoEXT - pRefFinalList1Entries / refFinalList1EntryCount
            for (uint32_t i = 0; i < pStruct->refFinalList1EntryCount; ++i)
                vk_struct_cleanup(&pStruct->pRefFinalList1Entries[i]);
            free(const_cast<VkVideoEncodeH264DpbSlotInfoEXT *>(pStruct->pRefFinalList1Entries));
        }

        break;
#endif // VK_ENABLE_BETA_EXTENSIONS

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
        {   // VkPhysicalDeviceInheritedViewportScissorFeaturesNV
            VkPhysicalDeviceInheritedViewportScissorFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceInheritedViewportScissorFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
        {   // VkCommandBufferInheritanceViewportScissorInfoNV
            VkCommandBufferInheritanceViewportScissorInfoNV const *pStruct = static_cast<VkCommandBufferInheritanceViewportScissorInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // VkViewport - pViewportDepths
            free(const_cast<VkViewport *>(pStruct->pViewportDepths));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
        {   // VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
            VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
        {   // VkPhysicalDeviceProvokingVertexFeaturesEXT
            VkPhysicalDeviceProvokingVertexFeaturesEXT const *pStruct = static_cast<VkPhysicalDeviceProvokingVertexFeaturesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
        {   // VkPhysicalDeviceProvokingVertexPropertiesEXT
            VkPhysicalDeviceProvokingVertexPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceProvokingVertexPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
        {   // VkPipelineRasterizationProvokingVertexStateCreateInfoEXT
            VkPipelineRasterizationProvokingVertexStateCreateInfoEXT const *pStruct = static_cast<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX:
        {   // VkCuModuleCreateInfoNVX
            VkCuModuleCreateInfoNVX const *pStruct = static_cast<VkCuModuleCreateInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // void - pData
            free(const_cast<void *>(pStruct->pData));
        }

        break;

    case VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX:
        {   // VkCuFunctionCreateInfoNVX
            VkCuFunctionCreateInfoNVX const *pStruct = static_cast<VkCuFunctionCreateInfoNVX const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));

            // char - pName / null-terminated
            free(const_cast<char *>(pStruct->pName));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
        {   // VkPhysicalDeviceDrmPropertiesEXT
            VkPhysicalDeviceDrmPropertiesEXT const *pStruct = static_cast<VkPhysicalDeviceDrmPropertiesEXT const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
        {   // VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
            VkPhysicalDeviceRayTracingMotionBlurFeaturesNV const *pStruct = static_cast<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
        {   // VkAccelerationStructureGeometryMotionTrianglesDataNV
            VkAccelerationStructureGeometryMotionTrianglesDataNV const *pStruct = static_cast<VkAccelerationStructureGeometryMotionTrianglesDataNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
        {   // VkAccelerationStructureMotionInfoNV
            VkAccelerationStructureMotionInfoNV const *pStruct = static_cast<VkAccelerationStructureMotionInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;

    case VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV:
        {   // VkMemoryGetRemoteAddressInfoNV
            VkMemoryGetRemoteAddressInfoNV const *pStruct = static_cast<VkMemoryGetRemoteAddressInfoNV const *>(pData);

            // void - pNext
            vk_struct_cleanup(pStruct->pNext);
            free(const_cast<void *>(pStruct->pNext));
        }

        break;


    default:
        break;
    }
}

#endif // VK_STRUCT_CLEANUP_CONFIG_MAIN

#endif // VK_STRUCT_CLEANUP_V185_HPP
